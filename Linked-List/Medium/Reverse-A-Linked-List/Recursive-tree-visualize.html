<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Recursive Reversal Tree Visualizer</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;600&family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", sans-serif;
        background: linear-gradient(
          135deg,
          #1a1a2e 0%,
          #16213e 50%,
          #0f3460 100%
        );
        min-height: 100vh;
        color: #fff;
        padding: 20px;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
      }

      .header h1 {
        font-size: 2.5rem;
        background: linear-gradient(
          135deg,
          #667eea 0%,
          #764ba2 50%,
          #f093fb 100%
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin-bottom: 10px;
      }

      .header p {
        color: #a0aec0;
        font-size: 1.1rem;
      }

      /* Control Panel */
      .controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 30px;
        flex-wrap: wrap;
      }

      .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 10px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .btn-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
      }

      .btn-secondary {
        background: rgba(255, 255, 255, 0.1);
        color: white;
        border: 2px solid rgba(255, 255, 255, 0.2);
      }

      .btn-secondary:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      .btn-success {
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        color: white;
      }

      .btn-warning {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      /* Speed control */
      .speed-control {
        display: flex;
        align-items: center;
        gap: 10px;
        background: rgba(255, 255, 255, 0.1);
        padding: 10px 20px;
        border-radius: 10px;
      }

      .speed-control label {
        font-size: 0.9rem;
        color: #a0aec0;
      }

      .speed-control input[type="range"] {
        width: 100px;
        accent-color: #667eea;
      }

      /* Main visualization area */
      .visualization-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
        margin-bottom: 30px;
      }

      @media (max-width: 1000px) {
        .visualization-container {
          grid-template-columns: 1fr;
        }
      }

      .panel {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 20px;
        padding: 25px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .panel-title {
        font-size: 1.3rem;
        font-weight: 600;
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .panel-title .icon {
        font-size: 1.5rem;
      }

      /* Linked List Visualization */
      .linked-list-container {
        min-height: 150px;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .list-state-label {
        font-size: 0.9rem;
        color: #a0aec0;
        text-align: center;
      }

      .linked-list {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 5px;
        flex-wrap: wrap;
        padding: 20px 0;
      }

      .node {
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: all 0.5s ease;
      }

      .node-box {
        display: flex;
        border: 3px solid #4a5568;
        border-radius: 10px;
        overflow: hidden;
        background: #2d3748;
        transition: all 0.5s ease;
      }

      .node-value {
        padding: 15px 20px;
        font-size: 1.5rem;
        font-weight: 700;
        border-right: 2px solid #4a5568;
        min-width: 50px;
        text-align: center;
        transition: all 0.5s ease;
      }

      .node-pointer {
        padding: 15px 12px;
        font-size: 1.2rem;
        color: #a0aec0;
      }

      .node-label {
        margin-top: 8px;
        font-size: 0.75rem;
        padding: 3px 10px;
        border-radius: 10px;
        font-weight: 600;
      }

      .label-head {
        background: rgba(102, 126, 234, 0.3);
        color: #667eea;
      }

      .label-newhead {
        background: rgba(56, 239, 125, 0.3);
        color: #38ef7d;
      }

      .arrow {
        font-size: 1.8rem;
        color: #4a5568;
        transition: all 0.5s ease;
      }

      .arrow-reversed {
        color: #38ef7d;
      }

      .arrow-processing {
        color: #f093fb;
        animation: pulse 0.5s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      .null-box {
        padding: 12px 18px;
        font-size: 1rem;
        font-weight: 600;
        color: #718096;
        border: 3px dashed #4a5568;
        border-radius: 10px;
        background: rgba(45, 55, 72, 0.5);
      }

      /* Node states */
      .node-active {
        border-color: #f093fb !important;
        box-shadow: 0 0 20px rgba(240, 147, 251, 0.5);
      }

      .node-active .node-value {
        background: rgba(240, 147, 251, 0.2);
      }

      .node-reversed {
        border-color: #38ef7d !important;
      }

      .node-reversed .node-value {
        background: rgba(56, 239, 125, 0.2);
        color: #38ef7d;
      }

      .node-waiting {
        border-color: #667eea !important;
      }

      .node-faded {
        opacity: 0.4;
      }

      /* Recursion Tree */
      .tree-container {
        min-height: 400px;
        overflow-x: auto;
      }

      .tree {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
        padding: 10px 0;
      }

      .tree-node {
        display: flex;
        align-items: center;
        gap: 15px;
        transition: all 0.5s ease;
      }

      .tree-indent {
        display: flex;
        align-items: center;
      }

      .tree-line {
        width: 30px;
        height: 2px;
        background: #4a5568;
      }

      .tree-connector {
        width: 2px;
        height: 40px;
        background: #4a5568;
        margin-left: 15px;
      }

      .tree-frame {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 12px 20px;
        border-radius: 10px;
        font-family: "Fira Code", monospace;
        font-size: 0.9rem;
        border: 2px solid;
        transition: all 0.5s ease;
      }

      .frame-waiting {
        background: rgba(102, 126, 234, 0.1);
        border-color: #667eea;
        color: #a0aec0;
      }

      .frame-active {
        background: rgba(240, 147, 251, 0.2);
        border-color: #f093fb;
        color: #fff;
        box-shadow: 0 0 20px rgba(240, 147, 251, 0.3);
      }

      .frame-base {
        background: rgba(245, 87, 108, 0.2);
        border-color: #f5576c;
        color: #fff;
      }

      .frame-returning {
        background: rgba(56, 239, 125, 0.2);
        border-color: #38ef7d;
        color: #38ef7d;
      }

      .frame-done {
        background: rgba(56, 239, 125, 0.1);
        border-color: #38ef7d;
        color: #718096;
        opacity: 0.6;
      }

      .frame-icon {
        font-size: 1.2rem;
      }

      .frame-status {
        font-size: 0.75rem;
        padding: 3px 8px;
        border-radius: 5px;
        margin-left: auto;
      }

      .status-diving {
        background: rgba(102, 126, 234, 0.3);
        color: #667eea;
      }

      .status-base {
        background: rgba(245, 87, 108, 0.3);
        color: #f5576c;
      }

      .status-reversing {
        background: rgba(240, 147, 251, 0.3);
        color: #f093fb;
      }

      .status-done {
        background: rgba(56, 239, 125, 0.3);
        color: #38ef7d;
      }

      /* Code Panel */
      .code-panel {
        background: #1a1a2e;
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 30px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .code-title {
        font-size: 1rem;
        color: #a0aec0;
        margin-bottom: 15px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .code-content {
        font-family: "Fira Code", monospace;
        font-size: 0.85rem;
        line-height: 1.8;
      }

      .code-line {
        padding: 5px 15px;
        border-radius: 5px;
        margin: 2px 0;
        transition: all 0.3s ease;
      }

      .code-line-active {
        background: rgba(240, 147, 251, 0.2);
        border-left: 3px solid #f093fb;
      }

      .code-keyword {
        color: #f093fb;
      }

      .code-function {
        color: #667eea;
      }

      .code-param {
        color: #38ef7d;
      }

      .code-comment {
        color: #718096;
      }

      .code-return {
        color: #f5576c;
      }

      /* Info Panel */
      .info-panel {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 15px;
        padding: 20px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .info-title {
        font-size: 1.1rem;
        font-weight: 600;
        margin-bottom: 15px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .info-content {
        font-size: 1rem;
        line-height: 1.6;
        color: #e2e8f0;
      }

      .info-highlight {
        display: inline-block;
        background: rgba(102, 126, 234, 0.2);
        padding: 2px 8px;
        border-radius: 5px;
        font-family: "Fira Code", monospace;
        font-size: 0.9rem;
        color: #667eea;
      }

      .info-code {
        display: block;
        background: rgba(0, 0, 0, 0.3);
        padding: 12px 15px;
        border-radius: 8px;
        margin: 10px 0;
        font-family: "Fira Code", monospace;
        font-size: 0.85rem;
        color: #f093fb;
      }

      /* Step Counter */
      .step-counter {
        display: flex;
        justify-content: center;
        gap: 30px;
        margin-bottom: 20px;
      }

      .counter-item {
        text-align: center;
      }

      .counter-value {
        font-size: 2rem;
        font-weight: 700;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .counter-label {
        font-size: 0.85rem;
        color: #a0aec0;
      }

      /* Phase Indicator */
      .phase-indicator {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-bottom: 20px;
      }

      .phase-badge {
        padding: 10px 25px;
        border-radius: 25px;
        font-weight: 600;
        font-size: 0.9rem;
        transition: all 0.3s ease;
      }

      .phase-dive {
        background: rgba(102, 126, 234, 0.2);
        border: 2px solid #667eea;
        color: #667eea;
      }

      .phase-dive.active {
        background: #667eea;
        color: white;
        box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
      }

      .phase-bubble {
        background: rgba(56, 239, 125, 0.2);
        border: 2px solid #38ef7d;
        color: #38ef7d;
      }

      .phase-bubble.active {
        background: #38ef7d;
        color: #1a1a2e;
        box-shadow: 0 0 20px rgba(56, 239, 125, 0.5);
      }

      /* Legend */
      .legend {
        display: flex;
        justify-content: center;
        gap: 25px;
        flex-wrap: wrap;
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.85rem;
        color: #a0aec0;
      }

      .legend-color {
        width: 16px;
        height: 16px;
        border-radius: 4px;
        border: 2px solid;
      }

      .legend-waiting {
        background: rgba(102, 126, 234, 0.3);
        border-color: #667eea;
      }

      .legend-active {
        background: rgba(240, 147, 251, 0.3);
        border-color: #f093fb;
      }

      .legend-base {
        background: rgba(245, 87, 108, 0.3);
        border-color: #f5576c;
      }

      .legend-done {
        background: rgba(56, 239, 125, 0.3);
        border-color: #38ef7d;
      }

      /* Custom Input */
      .input-group {
        display: flex;
        align-items: center;
        gap: 10px;
        background: rgba(255, 255, 255, 0.1);
        padding: 8px 15px;
        border-radius: 10px;
      }

      .input-group label {
        font-size: 0.9rem;
        color: #a0aec0;
      }

      .input-group input {
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 5px;
        padding: 8px 12px;
        color: white;
        font-size: 0.9rem;
        width: 150px;
        font-family: "Fira Code", monospace;
      }

      .input-group input:focus {
        outline: none;
        border-color: #667eea;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üå≥ Recursive Reversal Tree Visualizer</h1>
        <p>
          Watch the call stack build up and unwind as the linked list is
          reversed
        </p>
      </div>

      <!-- Controls -->
      <div class="controls">
        <div class="input-group">
          <label>List:</label>
          <input
            type="text"
            id="listInput"
            value="1,2,3,4,5"
            placeholder="e.g., 1,2,3,4,5"
          />
        </div>
        <button class="btn btn-secondary" id="resetBtn" onclick="reset()">
          üîÑ Reset
        </button>
        <button class="btn btn-primary" id="stepBtn" onclick="step()">
          ‚ñ∂Ô∏è Step
        </button>
        <button class="btn btn-success" id="autoBtn" onclick="toggleAuto()">
          ‚èØÔ∏è Auto Play
        </button>
        <button class="btn btn-warning" id="skipBtn" onclick="skipToEnd()">
          ‚è≠Ô∏è Skip to End
        </button>
        <div class="speed-control">
          <label>Speed:</label>
          <input
            type="range"
            id="speedSlider"
            min="100"
            max="2000"
            value="800"
          />
        </div>
      </div>

      <!-- Phase Indicator -->
      <div class="phase-indicator">
        <div class="phase-badge phase-dive" id="phaseDive">
          ‚¨áÔ∏è Phase 1: Diving Down
        </div>
        <div class="phase-badge phase-bubble" id="phaseBubble">
          ‚¨ÜÔ∏è Phase 2: Bubbling Up
        </div>
      </div>

      <!-- Step Counter -->
      <div class="step-counter">
        <div class="counter-item">
          <div class="counter-value" id="stepCount">0</div>
          <div class="counter-label">Steps</div>
        </div>
        <div class="counter-item">
          <div class="counter-value" id="stackDepth">0</div>
          <div class="counter-label">Stack Depth</div>
        </div>
        <div class="counter-item">
          <div class="counter-value" id="reversedCount">0</div>
          <div class="counter-label">Pointers Reversed</div>
        </div>
      </div>

      <!-- Main Visualization -->
      <div class="visualization-container">
        <!-- Recursion Tree Panel -->
        <div class="panel">
          <div class="panel-title">
            <span class="icon">üìö</span>
            Call Stack / Recursion Tree
          </div>
          <div class="tree-container">
            <div class="tree" id="treeContainer"></div>
          </div>
          <div class="legend">
            <div class="legend-item">
              <div class="legend-color legend-waiting"></div>
              <span>Waiting</span>
            </div>
            <div class="legend-item">
              <div class="legend-color legend-active"></div>
              <span>Active</span>
            </div>
            <div class="legend-item">
              <div class="legend-color legend-base"></div>
              <span>Base Case</span>
            </div>
            <div class="legend-item">
              <div class="legend-color legend-done"></div>
              <span>Done</span>
            </div>
          </div>
        </div>

        <!-- Linked List Panel -->
        <div class="panel">
          <div class="panel-title">
            <span class="icon">üîó</span>
            Linked List State
          </div>
          <div class="linked-list-container">
            <div class="list-state-label" id="listStateLabel">
              Initial State
            </div>
            <div class="linked-list" id="linkedList"></div>
          </div>
        </div>
      </div>

      <!-- Code + Info Panel -->
      <div class="visualization-container">
        <!-- Code Panel -->
        <div class="code-panel">
          <div class="code-title">
            <span>üíª</span>
            Code Execution
          </div>
          <div class="code-content">
            <div class="code-line" id="codeLine0">
              <span class="code-keyword">function</span>
              <span class="code-function">reverseList</span>(<span
                class="code-param"
                >head</span
              >) {
            </div>
            <div class="code-line" id="codeLine1">
              <span class="code-keyword">if</span> (head ==
              <span class="code-param">null</span> || head.next ==
              <span class="code-param">null</span>)
            </div>
            <div class="code-line" id="codeLine2">
              <span class="code-return">return</span> head;
              <span class="code-comment">// Base case</span>
            </div>
            <div class="code-line" id="codeLine3"></div>
            <div class="code-line" id="codeLine4">
              <span class="code-keyword">let</span> newHead =
              <span class="code-function">reverseList</span>(head.next);
              <span class="code-comment">// Recurse</span>
            </div>
            <div class="code-line" id="codeLine5"></div>
            <div class="code-line" id="codeLine6">
              head.next.next = head;
              <span class="code-comment">// Reverse pointer</span>
            </div>
            <div class="code-line" id="codeLine7">
              head.next = <span class="code-param">null</span>;
              <span class="code-comment">// Break old link</span>
            </div>
            <div class="code-line" id="codeLine8"></div>
            <div class="code-line" id="codeLine9">
              <span class="code-return">return</span> newHead;
            </div>
            <div class="code-line" id="codeLine10">}</div>
          </div>
        </div>

        <!-- Info Panel -->
        <div class="info-panel">
          <div class="info-title">
            <span>üí°</span>
            What's Happening
          </div>
          <div class="info-content" id="infoContent">
            Click <strong>Step</strong> or <strong>Auto Play</strong> to start
            the visualization. <br /><br />
            The algorithm will:
            <br />1. <strong>Dive down</strong> to the last node (building call
            stack) <br />2. <strong>Bubble up</strong> reversing one pointer at
            each level
          </div>
        </div>
      </div>
    </div>

    <script>
      // State
      let listValues = [1, 2, 3, 4, 5];
      let currentStep = 0;
      let totalSteps = 0;
      let phase = "idle"; // idle, diving, bubbling, done
      let callStack = [];
      let reversedNodes = new Set();
      let newHead = null;
      let autoPlaying = false;
      let autoInterval = null;

      // Steps data structure
      let steps = [];

      function init() {
        const input = document.getElementById("listInput").value;
        listValues = input
          .split(",")
          .map((v) => parseInt(v.trim()))
          .filter((v) => !isNaN(v));

        if (listValues.length === 0) {
          listValues = [1, 2, 3, 4, 5];
          document.getElementById("listInput").value = "1,2,3,4,5";
        }

        generateSteps();
        currentStep = 0;
        phase = "idle";
        callStack = [];
        reversedNodes = new Set();
        newHead = null;

        render();
        updateCounters();
      }

      function generateSteps() {
        steps = [];
        const n = listValues.length;

        if (n === 0) {
          steps.push({
            type: "empty",
            description: "Empty list - nothing to reverse!",
            codeLine: 1,
            phase: "done",
          });
          return;
        }

        if (n === 1) {
          steps.push({
            type: "single",
            description: `Single node (${listValues[0]}) - already reversed!`,
            codeLine: 1,
            phase: "done",
            activeNode: 0,
          });
          return;
        }

        // Generate diving steps
        for (let i = 0; i < n; i++) {
          if (i < n - 1) {
            // Normal dive step
            steps.push({
              type: "dive",
              depth: i,
              nodeValue: listValues[i],
              description: `Call reverseList(${listValues[i]}): head.next is not null, so recurse...`,
              codeLine: 4,
              phase: "diving",
              activeNode: i,
            });
          } else {
            // Base case
            steps.push({
              type: "base",
              depth: i,
              nodeValue: listValues[i],
              description: `BASE CASE! reverseList(${listValues[i]}): head.next is null. Return ${listValues[i]} as newHead.`,
              codeLine: 2,
              phase: "diving",
              activeNode: i,
              newHead: i,
            });
          }
        }

        // Generate bubbling steps
        for (let i = n - 2; i >= 0; i--) {
          // Reverse pointer step
          steps.push({
            type: "reverse",
            depth: i,
            nodeValue: listValues[i],
            nextValue: listValues[i + 1],
            description: `Back in reverseList(${
              listValues[i]
            }): Execute head.next.next = head ‚Üí ${listValues[i + 1]}.next = ${
              listValues[i]
            } (${listValues[i + 1]} now points to ${listValues[i]}!)`,
            codeLine: 6,
            phase: "bubbling",
            activeNode: i,
            reversingEdge: [i, i + 1],
          });

          // Break old link step
          steps.push({
            type: "break",
            depth: i,
            nodeValue: listValues[i],
            description: `Execute head.next = null ‚Üí ${listValues[i]}.next = null (${listValues[i]} becomes temporary tail)`,
            codeLine: 7,
            phase: "bubbling",
            activeNode: i,
            breakingNode: i,
          });

          // Return step
          steps.push({
            type: "return",
            depth: i,
            nodeValue: listValues[i],
            description: `Return newHead (${listValues[n - 1]}) to caller${
              i === 0 ? " - DONE!" : ""
            }`,
            codeLine: 9,
            phase: i === 0 ? "done" : "bubbling",
            activeNode: i,
            returningNode: i,
          });
        }

        totalSteps = steps.length;
      }

      function step() {
        if (currentStep >= steps.length) {
          phase = "done";
          render();
          return;
        }

        const stepData = steps[currentStep];
        applyStep(stepData);
        currentStep++;

        render();
        updateCounters();
      }

      function applyStep(stepData) {
        phase = stepData.phase;

        if (stepData.type === "dive") {
          callStack.push({
            depth: stepData.depth,
            nodeValue: stepData.nodeValue,
            status: "waiting",
          });
        } else if (stepData.type === "base") {
          callStack.push({
            depth: stepData.depth,
            nodeValue: stepData.nodeValue,
            status: "base",
          });
          newHead = stepData.nodeValue;
          reversedNodes.add(stepData.depth);
        } else if (stepData.type === "reverse") {
          // Mark the edge as reversed
          reversedNodes.add(stepData.depth);
        } else if (stepData.type === "return") {
          // Pop from call stack
          if (callStack.length > 0) {
            callStack[callStack.length - 1].status = "done";
            if (stepData.depth > 0) {
              callStack.pop();
            }
          }
        }
      }

      function render() {
        renderTree();
        renderLinkedList();
        renderCodeHighlight();
        renderInfo();
        updatePhaseIndicator();
      }

      function renderTree() {
        const container = document.getElementById("treeContainer");
        container.innerHTML = "";

        const n = listValues.length;

        for (let i = 0; i < n; i++) {
          const treeNode = document.createElement("div");
          treeNode.className = "tree-node";

          // Indentation
          const indent = document.createElement("div");
          indent.className = "tree-indent";
          for (let j = 0; j < i; j++) {
            const line = document.createElement("div");
            line.className = "tree-line";
            indent.appendChild(line);
          }
          if (i > 0) {
            const connector = document.createElement("span");
            connector.textContent = "‚Ü≥ ";
            connector.style.color = "#4a5568";
            indent.appendChild(connector);
          }
          treeNode.appendChild(indent);

          // Frame
          const frame = document.createElement("div");
          frame.className = "tree-frame";

          // Determine frame status
          const stackItem = callStack.find((item) => item.depth === i);
          let frameClass = "";
          let statusText = "";
          let statusClass = "";
          let icon = "";

          const currentStepData =
            currentStep > 0 ? steps[currentStep - 1] : null;
          const isCurrentActive =
            currentStepData && currentStepData.activeNode === i;

          if (!stackItem) {
            // Not yet called
            frameClass = "frame-waiting";
            icon = "‚è∏Ô∏è";
            statusText = "pending";
            statusClass = "status-diving";
            frame.style.opacity = "0.4";
          } else if (stackItem.status === "base") {
            frameClass = "frame-base";
            icon = "üéØ";
            statusText = "BASE";
            statusClass = "status-base";
          } else if (stackItem.status === "done") {
            frameClass = "frame-done";
            icon = "‚úÖ";
            statusText = "done";
            statusClass = "status-done";
          } else if (isCurrentActive && phase === "bubbling") {
            frameClass = "frame-returning";
            icon = "üîÑ";
            statusText = "reversing";
            statusClass = "status-reversing";
          } else if (stackItem.status === "waiting") {
            frameClass = "frame-waiting";
            icon = "‚è≥";
            statusText = "waiting";
            statusClass = "status-diving";
          }

          if (isCurrentActive && phase !== "done") {
            frameClass = "frame-active";
          }

          frame.classList.add(frameClass);

          frame.innerHTML = `
                    <span class="frame-icon">${icon}</span>
                    <span>reverseList(${listValues[i]})</span>
                    <span class="frame-status ${statusClass}">${statusText}</span>
                `;

          treeNode.appendChild(frame);
          container.appendChild(treeNode);
        }
      }

      function renderLinkedList() {
        const container = document.getElementById("linkedList");
        container.innerHTML = "";

        const n = listValues.length;
        const currentStepData = currentStep > 0 ? steps[currentStep - 1] : null;

        // Determine display order based on phase
        let displayOrder = [...listValues.keys()];

        for (let idx = 0; idx < n; idx++) {
          const i = displayOrder[idx];
          const value = listValues[i];

          // Node wrapper
          const nodeWrapper = document.createElement("div");
          nodeWrapper.className = "node";

          // Node box
          const nodeBox = document.createElement("div");
          nodeBox.className = "node-box";

          // Check states
          const isActive = currentStepData && currentStepData.activeNode === i;
          const isReversed = reversedNodes.has(i);
          const isNewHead = newHead === value;

          if (isActive && phase !== "done") {
            nodeBox.classList.add("node-active");
          } else if (isReversed) {
            nodeBox.classList.add("node-reversed");
          }

          // Node value
          const nodeValue = document.createElement("div");
          nodeValue.className = "node-value";
          nodeValue.textContent = value;

          // Node pointer
          const nodePointer = document.createElement("div");
          nodePointer.className = "node-pointer";
          nodePointer.textContent = "‚Ä¢";

          nodeBox.appendChild(nodeValue);
          nodeBox.appendChild(nodePointer);
          nodeWrapper.appendChild(nodeBox);

          // Labels
          if (isActive && phase !== "done") {
            const label = document.createElement("div");
            label.className = "node-label label-head";
            label.textContent = "head";
            nodeWrapper.appendChild(label);
          }

          if (isNewHead && phase !== "idle") {
            const label = document.createElement("div");
            label.className = "node-label label-newhead";
            label.textContent = "newHead";
            nodeWrapper.appendChild(label);
          }

          container.appendChild(nodeWrapper);

          // Arrow
          if (idx < n - 1) {
            const arrow = document.createElement("span");
            arrow.className = "arrow";

            // Check if this edge has been reversed
            const nextIdx = displayOrder[idx + 1];
            const edgeReversed =
              reversedNodes.has(i) && reversedNodes.has(nextIdx);

            if (
              currentStepData &&
              currentStepData.type === "reverse" &&
              currentStepData.reversingEdge &&
              currentStepData.reversingEdge[0] === i
            ) {
              arrow.classList.add("arrow-processing");
              arrow.textContent = "‚Üî";
            } else if (edgeReversed && phase === "bubbling") {
              arrow.classList.add("arrow-reversed");
              arrow.textContent = "‚Üê";
            } else {
              arrow.textContent = "‚Üí";
            }

            container.appendChild(arrow);
          }
        }

        // Null at the end
        const nullBox = document.createElement("div");
        nullBox.className = "null-box";
        nullBox.textContent = "null";

        // Add arrow before null
        const finalArrow = document.createElement("span");
        finalArrow.className = "arrow";
        finalArrow.textContent = "‚Üí";
        if (phase === "done") {
          finalArrow.classList.add("arrow-reversed");
        }
        container.appendChild(finalArrow);
        container.appendChild(nullBox);

        // Update label
        const label = document.getElementById("listStateLabel");
        if (phase === "idle") {
          label.textContent = "Initial State: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí null";
        } else if (phase === "diving") {
          label.textContent = "Diving down the call stack...";
        } else if (phase === "bubbling") {
          label.textContent = "Bubbling up & reversing pointers...";
        } else if (phase === "done") {
          label.textContent = `‚úÖ Reversed: ${listValues
            .slice()
            .reverse()
            .join(" ‚Üí ")} ‚Üí null`;
        }
      }

      function renderCodeHighlight() {
        // Clear all highlights
        for (let i = 0; i <= 10; i++) {
          document
            .getElementById(`codeLine${i}`)
            .classList.remove("code-line-active");
        }

        // Apply current highlight
        if (currentStep > 0 && currentStep <= steps.length) {
          const stepData = steps[currentStep - 1];
          if (stepData.codeLine !== undefined) {
            document
              .getElementById(`codeLine${stepData.codeLine}`)
              .classList.add("code-line-active");
          }
        }
      }

      function renderInfo() {
        const content = document.getElementById("infoContent");

        if (currentStep === 0 || phase === "idle") {
          content.innerHTML = `
                    Click <strong>Step</strong> or <strong>Auto Play</strong> to start the visualization.
                    <br><br>
                    The algorithm will:
                    <br>1. <strong>Dive down</strong> to the last node (building call stack)
                    <br>2. <strong>Bubble up</strong> reversing one pointer at each level
                `;
        } else if (currentStep <= steps.length) {
          const stepData = steps[currentStep - 1];
          let html = `<strong>Step ${currentStep}/${totalSteps}</strong><br><br>`;
          html += stepData.description;

          if (stepData.type === "reverse") {
            html += `<div class="info-code">head.next.next = head<br>// ${stepData.nextValue}.next = ${stepData.nodeValue}</div>`;
          } else if (stepData.type === "break") {
            html += `<div class="info-code">head.next = null<br>// ${stepData.nodeValue}.next = null</div>`;
          } else if (stepData.type === "base") {
            html += `<div class="info-code">return head; // returns ${stepData.nodeValue}</div>`;
            html += `<br>This node (${stepData.nodeValue}) will be the new head of the reversed list!`;
          }

          if (newHead !== null) {
            html += `<br><br>üìå <span class="info-highlight">newHead = ${newHead}</span> (passed through all returns)`;
          }

          content.innerHTML = html;
        } else {
          content.innerHTML = `
                    <strong>üéâ Complete!</strong>
                    <br><br>
                    The list has been successfully reversed!
                    <br><br>
                    Original: ${listValues.join(" ‚Üí ")} ‚Üí null
                    <br>
                    Reversed: ${listValues.slice().reverse().join(" ‚Üí ")} ‚Üí null
                    <br><br>
                    <strong>Complexity:</strong>
                    <br>‚Ä¢ Time: O(n) - visited each node once
                    <br>‚Ä¢ Space: O(n) - call stack depth
                `;
        }
      }

      function updatePhaseIndicator() {
        const diveEl = document.getElementById("phaseDive");
        const bubbleEl = document.getElementById("phaseBubble");

        diveEl.classList.remove("active");
        bubbleEl.classList.remove("active");

        if (phase === "diving") {
          diveEl.classList.add("active");
        } else if (phase === "bubbling" || phase === "done") {
          bubbleEl.classList.add("active");
        }
      }

      function updateCounters() {
        document.getElementById("stepCount").textContent = currentStep;
        document.getElementById("stackDepth").textContent = callStack.filter(
          (item) => item.status !== "done"
        ).length;
        document.getElementById("reversedCount").textContent = Math.max(
          0,
          reversedNodes.size - 1
        );
      }

      function reset() {
        stopAuto();
        init();
      }

      function toggleAuto() {
        if (autoPlaying) {
          stopAuto();
        } else {
          startAuto();
        }
      }

      function startAuto() {
        if (currentStep >= steps.length) {
          reset();
        }

        autoPlaying = true;
        document.getElementById("autoBtn").textContent = "‚è∏Ô∏è Pause";
        document.getElementById("autoBtn").classList.remove("btn-success");
        document.getElementById("autoBtn").classList.add("btn-warning");

        const speed = 2100 - document.getElementById("speedSlider").value;
        autoInterval = setInterval(() => {
          if (currentStep >= steps.length) {
            stopAuto();
            phase = "done";
            render();
          } else {
            step();
          }
        }, speed);
      }

      function stopAuto() {
        autoPlaying = false;
        document.getElementById("autoBtn").textContent = "‚èØÔ∏è Auto Play";
        document.getElementById("autoBtn").classList.remove("btn-warning");
        document.getElementById("autoBtn").classList.add("btn-success");

        if (autoInterval) {
          clearInterval(autoInterval);
          autoInterval = null;
        }
      }

      function skipToEnd() {
        stopAuto();
        while (currentStep < steps.length) {
          const stepData = steps[currentStep];
          applyStep(stepData);
          currentStep++;
        }
        phase = "done";
        render();
        updateCounters();
      }

      // Event listeners
      document.getElementById("listInput").addEventListener("change", reset);
      document.getElementById("speedSlider").addEventListener("input", () => {
        if (autoPlaying) {
          stopAuto();
          startAuto();
        }
      });

      // Initialize
      init();
    </script>
  </body>
</html>
