<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Animated Brute Force Merge Visualization</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;600&family=Poppins:wght@400;600;700&family=Permanent+Marker&family=Caveat:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Poppins", sans-serif;
        background: linear-gradient(
          135deg,
          #2d1b4e 0%,
          #1a1a2e 50%,
          #0d0d1a 100%
        );
        min-height: 100vh;
        padding: 20px;
        overflow-x: hidden;
      }

      .container {
        max-width: 1300px;
        margin: 0 auto;
      }

      /* Header */
      .header {
        text-align: center;
        margin-bottom: 25px;
      }

      .title {
        font-family: "Permanent Marker", cursive;
        font-size: 2.5rem;
        background: linear-gradient(90deg, #ff6b6b, #feca57, #ff9ff3);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin-bottom: 8px;
      }

      .subtitle {
        color: #a0aec0;
        font-size: 1.1rem;
      }

      .badge-slow {
        display: inline-block;
        background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
        color: white;
        padding: 5px 15px;
        border-radius: 20px;
        font-size: 0.85rem;
        margin-left: 10px;
        animation: pulseBadge 2s ease-in-out infinite;
      }

      @keyframes pulseBadge {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      /* Warning Box */
      .warning-box {
        background: linear-gradient(
          135deg,
          rgba(255, 107, 107, 0.15),
          rgba(255, 159, 243, 0.1)
        );
        border: 2px solid #ff6b6b;
        border-radius: 15px;
        padding: 18px 25px;
        margin-bottom: 25px;
        display: flex;
        align-items: center;
        gap: 15px;
        flex-wrap: wrap;
      }

      .warning-icon {
        font-size: 2rem;
      }

      .warning-text {
        flex: 1;
        min-width: 250px;
      }

      .warning-title {
        font-family: "Permanent Marker", cursive;
        font-size: 1.1rem;
        color: #ff6b6b;
        margin-bottom: 5px;
      }

      .warning-desc {
        color: #e0e0e0;
        font-size: 0.95rem;
        line-height: 1.5;
      }

      .warning-highlight {
        color: #feca57;
        font-weight: 600;
      }

      /* Step Display */
      .step-display {
        background: rgba(0, 0, 0, 0.4);
        border-radius: 15px;
        padding: 20px 30px;
        margin-bottom: 25px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        text-align: center;
      }

      .step-phase {
        font-family: "Caveat", cursive;
        font-size: 1.3rem;
        color: #feca57;
        margin-bottom: 8px;
      }

      .step-description {
        font-size: 1.1rem;
        color: #fff;
        margin-bottom: 15px;
        line-height: 1.6;
      }

      .step-description .highlight {
        color: #54a0ff;
        font-weight: 600;
      }
      .step-description .l1 {
        color: #54a0ff;
      }
      .step-description .l2 {
        color: #ff6b6b;
      }
      .step-description .sorted {
        color: #5f27cd;
      }
      .step-description .new-list {
        color: #1dd1a1;
      }

      .progress-container {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        height: 8px;
        overflow: hidden;
      }

      .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #ff6b6b, #feca57, #ff9ff3);
        border-radius: 10px;
        transition: width 0.3s ease;
      }

      /* Controls */
      .controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 25px;
        flex-wrap: wrap;
      }

      .control-btn {
        font-family: "Poppins", sans-serif;
        font-size: 1rem;
        font-weight: 600;
        padding: 12px 25px;
        border: none;
        border-radius: 30px;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .control-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .control-btn.prev {
        background: linear-gradient(135deg, #576574, #444);
        color: white;
      }

      .control-btn.next {
        background: linear-gradient(135deg, #54a0ff, #2e86de);
        color: white;
      }

      .control-btn.play {
        background: linear-gradient(135deg, #1dd1a1, #10ac84);
        color: white;
      }

      .control-btn.reset {
        background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
        color: white;
      }

      .control-btn:not(:disabled):hover {
        transform: translateY(-3px);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      }

      .speed-control {
        display: flex;
        align-items: center;
        gap: 10px;
        color: #a0aec0;
      }

      .speed-slider {
        width: 100px;
        height: 6px;
        border-radius: 3px;
        background: rgba(255, 255, 255, 0.2);
        outline: none;
        -webkit-appearance: none;
      }

      .speed-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #feca57;
        cursor: pointer;
      }

      /* Main Visualization */
      .viz-main {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 20px;
        padding: 30px;
        margin-bottom: 25px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      /* Phase Title */
      .phase-title {
        font-family: "Permanent Marker", cursive;
        font-size: 1.3rem;
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .phase-title.phase1 {
        color: #54a0ff;
      }
      .phase-title.phase2 {
        color: #ff6b6b;
      }
      .phase-title.phase3 {
        color: #5f27cd;
      }
      .phase-title.phase4 {
        color: #1dd1a1;
      }

      /* Source Lists */
      .source-lists {
        display: flex;
        flex-direction: column;
        gap: 25px;
        margin-bottom: 30px;
      }

      .list-row {
        display: flex;
        align-items: center;
        gap: 15px;
        flex-wrap: wrap;
      }

      .list-label {
        font-family: "Fira Code", monospace;
        font-size: 1rem;
        font-weight: 600;
        min-width: 70px;
      }

      .list-label.l1 {
        color: #54a0ff;
      }
      .list-label.l2 {
        color: #ff6b6b;
      }

      .nodes-container {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .node {
        width: 55px;
        height: 55px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: "Fira Code", monospace;
        font-size: 1.4rem;
        font-weight: 600;
        color: white;
        transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        position: relative;
      }

      .node.l1 {
        background: linear-gradient(135deg, #54a0ff, #2e86de);
      }
      .node.l2 {
        background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
      }

      .node.extracting {
        animation: extractPulse 0.6s ease-in-out;
      }

      @keyframes extractPulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.2);
          box-shadow: 0 0 30px currentColor;
        }
        100% {
          transform: scale(1);
        }
      }

      .node.extracted {
        opacity: 0.3;
        transform: scale(0.85);
      }

      .node.current {
        box-shadow: 0 0 25px rgba(255, 255, 255, 0.6);
        transform: scale(1.1);
      }

      .arrow {
        font-size: 1.4rem;
        color: rgba(255, 255, 255, 0.3);
      }

      .null-text {
        font-family: "Fira Code", monospace;
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.3);
        font-style: italic;
      }

      /* Array Section */
      .array-section {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 25px;
        border: 2px dashed rgba(255, 255, 255, 0.2);
      }

      .array-title {
        font-family: "Caveat", cursive;
        font-size: 1.3rem;
        color: #a0aec0;
        margin-bottom: 15px;
      }

      .array-container {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
        min-height: 60px;
      }

      .array-bracket {
        font-family: "Fira Code", monospace;
        font-size: 2.5rem;
        color: #feca57;
        font-weight: 300;
      }

      .array-element {
        width: 50px;
        height: 50px;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: "Fira Code", monospace;
        font-size: 1.3rem;
        font-weight: 600;
        color: white;
        opacity: 0;
        transform: translateY(-30px) scale(0);
        transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .array-element.visible {
        opacity: 1;
        transform: translateY(0) scale(1);
      }

      .array-element.from-l1 {
        background: linear-gradient(135deg, #54a0ff, #2e86de);
      }
      .array-element.from-l2 {
        background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
      }
      .array-element.sorted {
        background: linear-gradient(135deg, #5f27cd, #341f97);
      }

      .array-element.sorting {
        animation: sortBounce 0.3s ease-in-out;
      }

      @keyframes sortBounce {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-15px);
        }
      }

      .array-element.swapping {
        animation: swapGlow 0.5s ease-in-out;
      }

      @keyframes swapGlow {
        0%,
        100% {
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        50% {
          box-shadow: 0 0 30px #feca57;
        }
      }

      .array-comma {
        font-family: "Fira Code", monospace;
        font-size: 1.5rem;
        color: #666;
      }

      /* Sort Animation Container */
      .sort-section {
        background: linear-gradient(
          135deg,
          rgba(95, 39, 205, 0.15),
          rgba(52, 31, 151, 0.1)
        );
        border: 2px solid #5f27cd;
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 25px;
        text-align: center;
      }

      .sort-title {
        font-family: "Permanent Marker", cursive;
        font-size: 1.2rem;
        color: #a55eea;
        margin-bottom: 15px;
      }

      .sort-animation {
        display: flex;
        justify-content: center;
        align-items: flex-end;
        gap: 8px;
        height: 150px;
        padding: 20px;
      }

      .sort-bar {
        width: 40px;
        background: linear-gradient(180deg, #a55eea, #5f27cd);
        border-radius: 8px 8px 0 0;
        display: flex;
        align-items: flex-start;
        justify-content: center;
        padding-top: 8px;
        font-family: "Fira Code", monospace;
        font-size: 1rem;
        font-weight: 600;
        color: white;
        transition: all 0.4s ease;
        box-shadow: 0 4px 15px rgba(95, 39, 205, 0.4);
      }

      .sort-bar.comparing {
        background: linear-gradient(180deg, #feca57, #ff9f43);
        box-shadow: 0 0 25px rgba(254, 202, 87, 0.6);
      }

      .sort-bar.sorted {
        background: linear-gradient(180deg, #1dd1a1, #10ac84);
      }

      /* New List Section */
      .new-list-section {
        background: linear-gradient(
          135deg,
          rgba(29, 209, 161, 0.15),
          rgba(16, 172, 132, 0.1)
        );
        border: 2px solid #1dd1a1;
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 25px;
      }

      .new-list-title {
        font-family: "Permanent Marker", cursive;
        font-size: 1.2rem;
        color: #1dd1a1;
        margin-bottom: 15px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .new-list-nodes {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
        min-height: 70px;
      }

      .new-node {
        width: 55px;
        height: 55px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: "Fira Code", monospace;
        font-size: 1.4rem;
        font-weight: 600;
        color: white;
        background: linear-gradient(135deg, #1dd1a1, #10ac84);
        box-shadow: 0 4px 15px rgba(29, 209, 161, 0.4);
        opacity: 0;
        transform: scale(0) rotate(-180deg);
        transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      }

      .new-node.visible {
        opacity: 1;
        transform: scale(1) rotate(0deg);
      }

      .new-node.creating {
        animation: createPop 0.5s ease-out;
      }

      @keyframes createPop {
        0% {
          transform: scale(0) rotate(-180deg);
        }
        70% {
          transform: scale(1.2) rotate(10deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }

      .new-arrow {
        font-size: 1.4rem;
        color: #1dd1a1;
        opacity: 0;
        transition: all 0.3s ease;
      }

      .new-arrow.visible {
        opacity: 1;
      }

      /* Final Result */
      .final-result {
        background: linear-gradient(
          135deg,
          rgba(29, 209, 161, 0.2),
          rgba(16, 172, 132, 0.1)
        );
        border: 3px solid #1dd1a1;
        border-radius: 20px;
        padding: 30px;
        text-align: center;
        opacity: 0;
        transform: scale(0.9);
        transition: all 0.5s ease;
        margin-top: 25px;
      }

      .final-result.visible {
        opacity: 1;
        transform: scale(1);
      }

      .final-title {
        font-family: "Permanent Marker", cursive;
        font-size: 1.8rem;
        color: #1dd1a1;
        margin-bottom: 20px;
      }

      .final-nodes {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
        margin-bottom: 25px;
      }

      .final-node {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: "Fira Code", monospace;
        font-size: 1.5rem;
        font-weight: 700;
        color: white;
        background: linear-gradient(135deg, #1dd1a1, #10ac84);
        box-shadow: 0 5px 20px rgba(29, 209, 161, 0.4);
        opacity: 0;
        transform: scale(0);
        transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      }

      .final-node.visible {
        opacity: 1;
        transform: scale(1);
      }

      .final-arrow {
        font-size: 1.5rem;
        color: #1dd1a1;
        opacity: 0;
        transition: all 0.3s ease;
      }

      .final-arrow.visible {
        opacity: 1;
      }

      /* Complexity Warning */
      .complexity-warning {
        display: flex;
        justify-content: center;
        gap: 20px;
        flex-wrap: wrap;
        margin-bottom: 20px;
      }

      .complexity-card {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 15px;
        padding: 15px 25px;
        text-align: center;
        border: 2px solid;
      }

      .complexity-card.time {
        border-color: #ff6b6b;
      }

      .complexity-card.space {
        border-color: #feca57;
      }

      .complexity-label {
        font-size: 0.85rem;
        color: #a0aec0;
        margin-bottom: 5px;
      }

      .complexity-value {
        font-family: "Fira Code", monospace;
        font-size: 1.2rem;
        font-weight: 600;
      }

      .complexity-card.time .complexity-value {
        color: #ff6b6b;
      }
      .complexity-card.space .complexity-value {
        color: #feca57;
      }

      .complexity-note {
        font-size: 0.8rem;
        color: #888;
        margin-top: 5px;
      }

      /* Why Slow Box */
      .why-slow {
        background: rgba(255, 107, 107, 0.1);
        border: 2px dashed #ff6b6b;
        border-radius: 15px;
        padding: 20px;
        margin-top: 20px;
      }

      .why-slow-title {
        font-family: "Permanent Marker", cursive;
        font-size: 1.1rem;
        color: #ff6b6b;
        margin-bottom: 10px;
      }

      .why-slow-list {
        list-style: none;
        padding: 0;
      }

      .why-slow-list li {
        color: #e0e0e0;
        padding: 8px 0;
        padding-left: 25px;
        position: relative;
        font-size: 0.95rem;
      }

      .why-slow-list li::before {
        content: "‚úó";
        position: absolute;
        left: 0;
        color: #ff6b6b;
        font-weight: bold;
      }

      /* Responsive */
      @media (max-width: 768px) {
        .title {
          font-size: 1.8rem;
        }
        .node {
          width: 45px;
          height: 45px;
          font-size: 1.2rem;
        }
        .array-element {
          width: 40px;
          height: 40px;
          font-size: 1.1rem;
        }
        .sort-bar {
          width: 30px;
          font-size: 0.9rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Header -->
      <div class="header">
        <h1 class="title">üê¢ Brute Force Merge</h1>
        <p class="subtitle">
          The "just get it done" approach
          <span class="badge-slow">O(n log n) - SLOW!</span>
        </p>
      </div>

      <!-- Warning Box -->
      <div class="warning-box">
        <div class="warning-icon">‚ö†Ô∏è</div>
        <div class="warning-text">
          <div class="warning-title">Why This Approach is Suboptimal</div>
          <div class="warning-desc">
            This approach
            <span class="warning-highlight"
              >ignores that both lists are already sorted</span
            >! We extract all values, sort them again, then build a completely
            new list. It works, but wastes time and memory.
          </div>
        </div>
      </div>

      <!-- Step Display -->
      <div class="step-display">
        <div class="step-phase" id="stepPhase">Ready to start</div>
        <div class="step-description" id="stepDescription">
          Click <span class="highlight">Next</span> or
          <span class="highlight">Play</span> to see how brute force works
        </div>
        <div class="progress-container">
          <div class="progress-bar" id="progressBar" style="width: 0%"></div>
        </div>
      </div>

      <!-- Controls -->
      <div class="controls">
        <button class="control-btn prev" id="prevBtn" onclick="prevStep()">
          <span>‚Üê</span> Previous
        </button>
        <button class="control-btn next" id="nextBtn" onclick="nextStep()">
          Next <span>‚Üí</span>
        </button>
        <button class="control-btn play" id="playBtn" onclick="togglePlay()">
          <span id="playIcon">‚ñ∂</span> <span id="playText">Play</span>
        </button>
        <button class="control-btn reset" onclick="resetAnimation()">
          <span>‚Ü∫</span> Reset
        </button>
        <div class="speed-control">
          <span>Speed:</span>
          <input
            type="range"
            class="speed-slider"
            id="speedSlider"
            min="400"
            max="2000"
            value="1000"
            onchange="updateSpeed()"
          />
        </div>
      </div>

      <!-- Main Visualization -->
      <div class="viz-main">
        <!-- Phase 1 & 2: Source Lists -->
        <div class="phase-title phase1" id="phaseTitle1">
          <span>üìã</span>
          <span>Step 1 & 2: Extract Values from Both Lists</span>
        </div>

        <div class="source-lists">
          <!-- List 1 -->
          <div class="list-row">
            <span class="list-label l1">list1:</span>
            <div class="nodes-container" id="list1Container"></div>
          </div>

          <!-- List 2 -->
          <div class="list-row">
            <span class="list-label l2">list2:</span>
            <div class="nodes-container" id="list2Container"></div>
          </div>
        </div>

        <!-- Array Collection -->
        <div class="array-section" id="arraySection">
          <div class="array-title">üì¶ Collected Values Array:</div>
          <div class="array-container" id="arrayContainer">
            <span class="array-bracket">[</span>
            <span id="arrayElements"></span>
            <span class="array-bracket">]</span>
          </div>
        </div>

        <!-- Sort Section -->
        <div class="sort-section" id="sortSection" style="display: none">
          <div class="phase-title phase3" style="justify-content: center">
            <span>üîÄ</span>
            <span>Step 3: Sort the Array</span>
          </div>
          <div class="sort-animation" id="sortAnimation"></div>
        </div>

        <!-- New List Section -->
        <div class="new-list-section" id="newListSection" style="display: none">
          <div class="new-list-title">
            <span>üî®</span>
            <span>Step 4: Build New Linked List</span>
          </div>
          <div class="new-list-nodes" id="newListNodes"></div>
        </div>
      </div>

      <!-- Final Result -->
      <div class="final-result" id="finalResult">
        <div class="final-title">‚úÖ Brute Force Complete!</div>
        <div class="final-nodes" id="finalNodes">
          <div class="final-node">1</div>
          <span class="final-arrow">‚Üí</span>
          <div class="final-node">1</div>
          <span class="final-arrow">‚Üí</span>
          <div class="final-node">2</div>
          <span class="final-arrow">‚Üí</span>
          <div class="final-node">3</div>
          <span class="final-arrow">‚Üí</span>
          <div class="final-node">4</div>
          <span class="final-arrow">‚Üí</span>
          <div class="final-node">4</div>
        </div>

        <div class="complexity-warning">
          <div class="complexity-card time">
            <div class="complexity-label">Time Complexity</div>
            <div class="complexity-value">O((n+m) log(n+m))</div>
            <div class="complexity-note">Sorting dominates!</div>
          </div>
          <div class="complexity-card space">
            <div class="complexity-label">Space Complexity</div>
            <div class="complexity-value">O(n + m)</div>
            <div class="complexity-note">Array + new nodes</div>
          </div>
        </div>

        <div class="why-slow">
          <div class="why-slow-title">‚ùå Why This is Not Optimal</div>
          <ul class="why-slow-list">
            <li>
              <strong>Ignores sorted property</strong> ‚Äî Lists are already
              sorted, but we re-sort anyway!
            </li>
            <li>
              <strong>Creates new nodes</strong> ‚Äî Problem asks to "splice"
              existing nodes, not copy
            </li>
            <li>
              <strong>Extra memory</strong> ‚Äî Array storage + new linked list
              nodes
            </li>
            <li>
              <strong>O(n log n) vs O(n)</strong> ‚Äî Two-pointer approach is much
              faster!
            </li>
          </ul>
        </div>
      </div>
    </div>

    <script>
      // Data
      const list1 = [1, 2, 4];
      const list2 = [1, 3, 4];

      // Animation state
      let currentStep = -1;
      let isPlaying = false;
      let playInterval = null;
      let animationSpeed = 1000;

      // Steps definition
      const steps = [
        // Phase 1: Extract from list1
        {
          phase: "PHASE 1: Traverse list1",
          description:
            'Start traversing <span class="l1">list1</span> to collect values',
          extracting: { list: 1, index: -1 },
          array: [],
          showSort: false,
          showNewList: false,
        },
        {
          phase: "PHASE 1: Extract value",
          description:
            'Extract <span class="l1">1</span> from list1 and add to array',
          extracting: { list: 1, index: 0 },
          array: [{ val: 1, from: "l1" }],
          showSort: false,
          showNewList: false,
        },
        {
          phase: "PHASE 1: Extract value",
          description:
            'Extract <span class="l1">2</span> from list1 and add to array',
          extracting: { list: 1, index: 1 },
          array: [
            { val: 1, from: "l1" },
            { val: 2, from: "l1" },
          ],
          showSort: false,
          showNewList: false,
        },
        {
          phase: "PHASE 1: Extract value",
          description:
            'Extract <span class="l1">4</span> from list1 and add to array',
          extracting: { list: 1, index: 2 },
          array: [
            { val: 1, from: "l1" },
            { val: 2, from: "l1" },
            { val: 4, from: "l1" },
          ],
          showSort: false,
          showNewList: false,
        },
        // Phase 2: Extract from list2
        {
          phase: "PHASE 2: Traverse list2",
          description:
            'Now traverse <span class="l2">list2</span> to collect remaining values',
          extracting: { list: 2, index: -1 },
          array: [
            { val: 1, from: "l1" },
            { val: 2, from: "l1" },
            { val: 4, from: "l1" },
          ],
          showSort: false,
          showNewList: false,
        },
        {
          phase: "PHASE 2: Extract value",
          description:
            'Extract <span class="l2">1</span> from list2 and add to array',
          extracting: { list: 2, index: 0 },
          array: [
            { val: 1, from: "l1" },
            { val: 2, from: "l1" },
            { val: 4, from: "l1" },
            { val: 1, from: "l2" },
          ],
          showSort: false,
          showNewList: false,
        },
        {
          phase: "PHASE 2: Extract value",
          description:
            'Extract <span class="l2">3</span> from list2 and add to array',
          extracting: { list: 2, index: 1 },
          array: [
            { val: 1, from: "l1" },
            { val: 2, from: "l1" },
            { val: 4, from: "l1" },
            { val: 1, from: "l2" },
            { val: 3, from: "l2" },
          ],
          showSort: false,
          showNewList: false,
        },
        {
          phase: "PHASE 2: Extract value",
          description:
            'Extract <span class="l2">4</span> from list2 and add to array',
          extracting: { list: 2, index: 2 },
          array: [
            { val: 1, from: "l1" },
            { val: 2, from: "l1" },
            { val: 4, from: "l1" },
            { val: 1, from: "l2" },
            { val: 3, from: "l2" },
            { val: 4, from: "l2" },
          ],
          showSort: false,
          showNewList: false,
        },
        // Phase 3: Sort
        {
          phase: "PHASE 3: Sort Array",
          description:
            'Array is <span class="highlight">NOT sorted</span>! Call sort() ‚Äî this costs <span class="highlight">O(n log n)</span>!',
          extracting: null,
          array: [
            { val: 1, from: "l1" },
            { val: 2, from: "l1" },
            { val: 4, from: "l1" },
            { val: 1, from: "l2" },
            { val: 3, from: "l2" },
            { val: 4, from: "l2" },
          ],
          showSort: true,
          sortState: "before",
          showNewList: false,
        },
        {
          phase: "PHASE 3: Sorting...",
          description:
            'Comparing and swapping elements... <span class="sorted">[1, 1, 2, 3, 4, 4]</span>',
          extracting: null,
          array: [
            { val: 1, from: "sorted" },
            { val: 1, from: "sorted" },
            { val: 2, from: "sorted" },
            { val: 3, from: "sorted" },
            { val: 4, from: "sorted" },
            { val: 4, from: "sorted" },
          ],
          showSort: true,
          sortState: "sorting",
          showNewList: false,
        },
        {
          phase: "PHASE 3: Sort Complete!",
          description:
            'Array is now sorted: <span class="sorted">[1, 1, 2, 3, 4, 4]</span>',
          extracting: null,
          array: [
            { val: 1, from: "sorted" },
            { val: 1, from: "sorted" },
            { val: 2, from: "sorted" },
            { val: 3, from: "sorted" },
            { val: 4, from: "sorted" },
            { val: 4, from: "sorted" },
          ],
          showSort: true,
          sortState: "after",
          showNewList: false,
        },
        // Phase 4: Build new list
        {
          phase: "PHASE 4: Build New List",
          description:
            'Create <span class="new-list">new ListNode</span> for each value in sorted array',
          extracting: null,
          array: [
            { val: 1, from: "sorted" },
            { val: 1, from: "sorted" },
            { val: 2, from: "sorted" },
            { val: 3, from: "sorted" },
            { val: 4, from: "sorted" },
            { val: 4, from: "sorted" },
          ],
          showSort: false,
          showNewList: true,
          newListNodes: [],
        },
        {
          phase: "PHASE 4: Create Node",
          description:
            'Create node with value <span class="new-list">1</span> (head of new list)',
          extracting: null,
          array: [
            { val: 1, from: "sorted" },
            { val: 1, from: "sorted" },
            { val: 2, from: "sorted" },
            { val: 3, from: "sorted" },
            { val: 4, from: "sorted" },
            { val: 4, from: "sorted" },
          ],
          showSort: false,
          showNewList: true,
          newListNodes: [1],
          creatingIndex: 0,
        },
        {
          phase: "PHASE 4: Create Node",
          description:
            'Create node with value <span class="new-list">1</span> and link to previous',
          extracting: null,
          array: [
            { val: 1, from: "sorted" },
            { val: 1, from: "sorted" },
            { val: 2, from: "sorted" },
            { val: 3, from: "sorted" },
            { val: 4, from: "sorted" },
            { val: 4, from: "sorted" },
          ],
          showSort: false,
          showNewList: true,
          newListNodes: [1, 1],
          creatingIndex: 1,
        },
        {
          phase: "PHASE 4: Create Node",
          description:
            'Create node with value <span class="new-list">2</span> and link to previous',
          extracting: null,
          array: [
            { val: 1, from: "sorted" },
            { val: 1, from: "sorted" },
            { val: 2, from: "sorted" },
            { val: 3, from: "sorted" },
            { val: 4, from: "sorted" },
            { val: 4, from: "sorted" },
          ],
          showSort: false,
          showNewList: true,
          newListNodes: [1, 1, 2],
          creatingIndex: 2,
        },
        {
          phase: "PHASE 4: Create Node",
          description:
            'Create node with value <span class="new-list">3</span> and link to previous',
          extracting: null,
          array: [
            { val: 1, from: "sorted" },
            { val: 1, from: "sorted" },
            { val: 2, from: "sorted" },
            { val: 3, from: "sorted" },
            { val: 4, from: "sorted" },
            { val: 4, from: "sorted" },
          ],
          showSort: false,
          showNewList: true,
          newListNodes: [1, 1, 2, 3],
          creatingIndex: 3,
        },
        {
          phase: "PHASE 4: Create Node",
          description:
            'Create node with value <span class="new-list">4</span> and link to previous',
          extracting: null,
          array: [
            { val: 1, from: "sorted" },
            { val: 1, from: "sorted" },
            { val: 2, from: "sorted" },
            { val: 3, from: "sorted" },
            { val: 4, from: "sorted" },
            { val: 4, from: "sorted" },
          ],
          showSort: false,
          showNewList: true,
          newListNodes: [1, 1, 2, 3, 4],
          creatingIndex: 4,
        },
        {
          phase: "PHASE 4: Create Node",
          description:
            'Create node with value <span class="new-list">4</span> and link to previous',
          extracting: null,
          array: [
            { val: 1, from: "sorted" },
            { val: 1, from: "sorted" },
            { val: 2, from: "sorted" },
            { val: 3, from: "sorted" },
            { val: 4, from: "sorted" },
            { val: 4, from: "sorted" },
          ],
          showSort: false,
          showNewList: true,
          newListNodes: [1, 1, 2, 3, 4, 4],
          creatingIndex: 5,
        },
        // Complete
        {
          phase: "‚úÖ COMPLETE",
          description:
            'Return head of new list: <span class="new-list">[1 ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 4]</span>',
          extracting: null,
          array: [
            { val: 1, from: "sorted" },
            { val: 1, from: "sorted" },
            { val: 2, from: "sorted" },
            { val: 3, from: "sorted" },
            { val: 4, from: "sorted" },
            { val: 4, from: "sorted" },
          ],
          showSort: false,
          showNewList: true,
          newListNodes: [1, 1, 2, 3, 4, 4],
          complete: true,
        },
      ];

      // Initialize
      function init() {
        renderSourceLists();
        updateDisplay();
      }

      // Render source lists
      function renderSourceLists() {
        const list1Container = document.getElementById("list1Container");
        const list2Container = document.getElementById("list2Container");

        list1Container.innerHTML = "";
        list2Container.innerHTML = "";

        // Render list1
        list1.forEach((val, idx) => {
          const node = document.createElement("div");
          node.className = "node l1";
          node.id = `l1-node-${idx}`;
          node.textContent = val;
          list1Container.appendChild(node);

          if (idx < list1.length - 1) {
            const arrow = document.createElement("span");
            arrow.className = "arrow";
            arrow.textContent = "‚Üí";
            list1Container.appendChild(arrow);
          }
        });

        const arrow1 = document.createElement("span");
        arrow1.className = "arrow";
        arrow1.textContent = "‚Üí";
        list1Container.appendChild(arrow1);
        const null1 = document.createElement("span");
        null1.className = "null-text";
        null1.textContent = "null";
        list1Container.appendChild(null1);

        // Render list2
        list2.forEach((val, idx) => {
          const node = document.createElement("div");
          node.className = "node l2";
          node.id = `l2-node-${idx}`;
          node.textContent = val;
          list2Container.appendChild(node);

          if (idx < list2.length - 1) {
            const arrow = document.createElement("span");
            arrow.className = "arrow";
            arrow.textContent = "‚Üí";
            list2Container.appendChild(arrow);
          }
        });

        const arrow2 = document.createElement("span");
        arrow2.className = "arrow";
        arrow2.textContent = "‚Üí";
        list2Container.appendChild(arrow2);
        const null2 = document.createElement("span");
        null2.className = "null-text";
        null2.textContent = "null";
        list2Container.appendChild(null2);
      }

      // Update display
      function updateDisplay() {
        const totalSteps = steps.length;
        const progress = ((currentStep + 1) / totalSteps) * 100;
        document.getElementById("progressBar").style.width = progress + "%";

        // Reset nodes
        list1.forEach((_, idx) => {
          const node = document.getElementById(`l1-node-${idx}`);
          node.classList.remove("extracting", "extracted", "current");
        });
        list2.forEach((_, idx) => {
          const node = document.getElementById(`l2-node-${idx}`);
          node.classList.remove("extracting", "extracted", "current");
        });

        // Hide sections by default
        document.getElementById("sortSection").style.display = "none";
        document.getElementById("newListSection").style.display = "none";
        document.getElementById("finalResult").classList.remove("visible");

        if (currentStep >= 0 && currentStep < steps.length) {
          const step = steps[currentStep];

          // Update step display
          document.getElementById("stepPhase").textContent = `Step ${
            currentStep + 1
          } of ${totalSteps}: ${step.phase}`;
          document.getElementById("stepDescription").innerHTML =
            step.description;

          // Handle extraction highlighting
          if (step.extracting) {
            const list = step.extracting.list;
            const idx = step.extracting.index;
            const listArr = list === 1 ? list1 : list2;
            const prefix = list === 1 ? "l1" : "l2";

            // Mark extracted nodes
            for (let i = 0; i < idx; i++) {
              document
                .getElementById(`${prefix}-node-${i}`)
                .classList.add("extracted");
            }

            // Mark current extracting node
            if (idx >= 0 && idx < listArr.length) {
              document
                .getElementById(`${prefix}-node-${idx}`)
                .classList.add("current", "extracting");
            }

            // Mark all list1 as extracted when moving to list2
            if (list === 2) {
              list1.forEach((_, i) => {
                document
                  .getElementById(`l1-node-${i}`)
                  .classList.add("extracted");
              });
            }
          } else {
            // All extracted after extraction phases
            if (currentStep >= 8) {
              list1.forEach((_, i) => {
                document
                  .getElementById(`l1-node-${i}`)
                  .classList.add("extracted");
              });
              list2.forEach((_, i) => {
                document
                  .getElementById(`l2-node-${i}`)
                  .classList.add("extracted");
              });
            }
          }

          // Render array
          renderArray(step.array);

          // Show sort section
          if (step.showSort) {
            document.getElementById("sortSection").style.display = "block";
            renderSortAnimation(step.sortState, step.array);
          }

          // Show new list section
          if (step.showNewList) {
            document.getElementById("newListSection").style.display = "block";
            renderNewList(step.newListNodes || [], step.creatingIndex);
          }

          // Show final result
          if (step.complete) {
            document.getElementById("finalResult").classList.add("visible");
            animateFinalResult();
          }
        } else {
          document.getElementById("stepPhase").textContent = "Ready to start";
          document.getElementById("stepDescription").innerHTML =
            'Click <span class="highlight">Next</span> or <span class="highlight">Play</span> to see brute force in action';
          renderArray([]);
        }

        updateButtons();
      }

      // Render array
      function renderArray(array) {
        const container = document.getElementById("arrayElements");
        container.innerHTML = "";

        array.forEach((item, idx) => {
          const el = document.createElement("span");
          el.className = `array-element from-${item.from}`;
          el.textContent = item.val;
          el.id = `array-el-${idx}`;

          setTimeout(() => {
            el.classList.add("visible");
          }, idx * 80);

          container.appendChild(el);

          if (idx < array.length - 1) {
            const comma = document.createElement("span");
            comma.className = "array-comma";
            comma.textContent = ",";
            container.appendChild(comma);
          }
        });
      }

      // Render sort animation
      function renderSortAnimation(state, array) {
        const container = document.getElementById("sortAnimation");
        container.innerHTML = "";

        const unsorted = [1, 2, 4, 1, 3, 4];
        const sorted = [1, 1, 2, 3, 4, 4];
        const values = state === "after" ? sorted : unsorted;

        values.forEach((val, idx) => {
          const bar = document.createElement("div");
          bar.className = "sort-bar";
          bar.style.height = val * 25 + 20 + "px";
          bar.textContent = val;

          if (state === "sorting") {
            bar.classList.add("comparing");
            bar.style.animationDelay = idx * 0.1 + "s";
          }

          if (state === "after") {
            bar.classList.add("sorted");
          }

          container.appendChild(bar);
        });
      }

      // Render new list
      function renderNewList(nodes, creatingIndex) {
        const container = document.getElementById("newListNodes");
        container.innerHTML = "";

        nodes.forEach((val, idx) => {
          const node = document.createElement("div");
          node.className = "new-node";
          node.textContent = val;

          setTimeout(() => {
            node.classList.add("visible");
            if (idx === creatingIndex) {
              node.classList.add("creating");
            }
          }, idx * 100);

          container.appendChild(node);

          if (idx < nodes.length - 1) {
            const arrow = document.createElement("span");
            arrow.className = "new-arrow";
            arrow.textContent = "‚Üí";
            setTimeout(() => arrow.classList.add("visible"), idx * 100 + 150);
            container.appendChild(arrow);
          }
        });

        // Add null
        if (nodes.length > 0) {
          const arrow = document.createElement("span");
          arrow.className = "new-arrow";
          arrow.textContent = "‚Üí";
          setTimeout(() => arrow.classList.add("visible"), nodes.length * 100);
          container.appendChild(arrow);

          const nullText = document.createElement("span");
          nullText.className = "null-text";
          nullText.textContent = "null";
          nullText.style.opacity = "0";
          setTimeout(
            () => (nullText.style.opacity = "0.3"),
            nodes.length * 100 + 100
          );
          container.appendChild(nullText);
        }
      }

      // Animate final result
      function animateFinalResult() {
        const nodes = document.querySelectorAll("#finalNodes .final-node");
        const arrows = document.querySelectorAll("#finalNodes .final-arrow");

        nodes.forEach((node, idx) => {
          setTimeout(() => {
            node.classList.add("visible");
            if (arrows[idx]) {
              setTimeout(() => arrows[idx].classList.add("visible"), 100);
            }
          }, idx * 150);
        });
      }

      // Update buttons
      function updateButtons() {
        document.getElementById("prevBtn").disabled = currentStep < 0;
        document.getElementById("nextBtn").disabled =
          currentStep >= steps.length - 1;
      }

      // Navigation
      function nextStep() {
        if (currentStep < steps.length - 1) {
          currentStep++;
          updateDisplay();
        } else {
          stopPlay();
        }
      }

      function prevStep() {
        if (currentStep >= 0) {
          currentStep--;
          updateDisplay();
        }
      }

      function resetAnimation() {
        stopPlay();
        currentStep = -1;
        // Reset final result
        document
          .querySelectorAll(".final-node")
          .forEach((n) => n.classList.remove("visible"));
        document
          .querySelectorAll(".final-arrow")
          .forEach((a) => a.classList.remove("visible"));
        updateDisplay();
      }

      function togglePlay() {
        if (isPlaying) {
          stopPlay();
        } else {
          startPlay();
        }
      }

      function startPlay() {
        isPlaying = true;
        document.getElementById("playIcon").textContent = "‚è∏";
        document.getElementById("playText").textContent = "Pause";
        document.getElementById("playBtn").style.background =
          "linear-gradient(135deg, #ff6b6b, #ee5a5a)";

        playInterval = setInterval(() => {
          if (currentStep < steps.length - 1) {
            nextStep();
          } else {
            stopPlay();
          }
        }, animationSpeed);
      }

      function stopPlay() {
        isPlaying = false;
        document.getElementById("playIcon").textContent = "‚ñ∂";
        document.getElementById("playText").textContent = "Play";
        document.getElementById("playBtn").style.background =
          "linear-gradient(135deg, #1dd1a1, #10ac84)";

        if (playInterval) {
          clearInterval(playInterval);
          playInterval = null;
        }
      }

      function updateSpeed() {
        animationSpeed = 2500 - document.getElementById("speedSlider").value;
        if (isPlaying) {
          stopPlay();
          startPlay();
        }
      }

      // Keyboard controls
      document.addEventListener("keydown", (e) => {
        if (e.key === "ArrowRight" || e.key === " ") {
          e.preventDefault();
          nextStep();
        } else if (e.key === "ArrowLeft") {
          e.preventDefault();
          prevStep();
        } else if (e.key === "p" || e.key === "P") {
          togglePlay();
        } else if (e.key === "r" || e.key === "R") {
          resetAnimation();
        }
      });

      // Initialize
      init();
    </script>
  </body>
</html>
