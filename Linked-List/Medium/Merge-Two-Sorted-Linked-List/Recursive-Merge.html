<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Whiteboard: Merge Two Sorted Lists (Recursive Approach)</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;600;700&family=Indie+Flower&family=Patrick+Hand&family=Permanent+Marker&family=Architects+Daughter&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Patrick Hand", cursive;
        background: linear-gradient(
          135deg,
          #0d1b2a 0%,
          #1b263b 50%,
          #415a77 100%
        );
        min-height: 100vh;
        padding: 20px;
        overflow-x: hidden;
      }

      .whiteboard {
        background: linear-gradient(
          160deg,
          #fefae0 0%,
          #faedcd 30%,
          #fefae0 60%,
          #e9edc9 100%
        );
        border-radius: 4px;
        padding: 40px;
        max-width: 1400px;
        margin: 0 auto;
        box-shadow: 0 30px 100px rgba(0, 0, 0, 0.5),
          inset 0 0 80px rgba(0, 0, 0, 0.03), 0 0 0 3px #d4a373,
          0 0 0 6px #bc6c25, 0 0 0 10px #dda15e;
        position: relative;
        min-height: 95vh;
      }

      /* Paper texture */
      .whiteboard::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-image: repeating-linear-gradient(
          0deg,
          transparent,
          transparent 31px,
          #d4e4ed 31px,
          #d4e4ed 32px
        );
        opacity: 0.3;
        pointer-events: none;
        border-radius: 4px;
      }

      /* Red margin line */
      .whiteboard::after {
        content: "";
        position: absolute;
        top: 0;
        left: 80px;
        bottom: 0;
        width: 2px;
        background: #e76f51;
        opacity: 0.4;
      }

      .title {
        font-family: "Permanent Marker", cursive;
        font-size: 2.6rem;
        color: #bc6c25;
        text-align: center;
        margin-bottom: 5px;
        text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.1);
      }

      .subtitle {
        font-family: "Architects Daughter", cursive;
        font-size: 1.5rem;
        color: #e76f51;
        text-align: center;
        margin-bottom: 25px;
      }

      /* Recursion Concept Box */
      .concept-box {
        background: linear-gradient(135deg, #d8f3dc, #b7e4c7);
        border: 3px solid #52b788;
        border-radius: 15px;
        padding: 20px 25px;
        margin-bottom: 25px;
        position: relative;
        box-shadow: 5px 5px 0 rgba(82, 183, 136, 0.3);
      }

      .concept-box::before {
        content: "üîÑ RECURSIVE INSIGHT";
        position: absolute;
        top: -14px;
        left: 25px;
        background: #52b788;
        padding: 3px 15px;
        border-radius: 20px;
        font-family: "Permanent Marker", cursive;
        font-size: 0.95rem;
        color: white;
      }

      .concept-text {
        font-size: 1.2rem;
        color: #1b4332;
        line-height: 1.7;
      }

      .concept-formula {
        font-family: "Architects Daughter", cursive;
        font-size: 1.3rem;
        color: #081c15;
        background: rgba(255, 255, 255, 0.6);
        padding: 12px 20px;
        border-radius: 10px;
        margin-top: 12px;
        border-left: 4px solid #40916c;
      }

      .formula-highlight {
        color: #e76f51;
        font-weight: 700;
      }

      /* Problem Box */
      .problem-box {
        background: rgba(255, 255, 255, 0.5);
        border: 2px dashed #bc6c25;
        border-radius: 12px;
        padding: 15px 25px;
        margin-bottom: 25px;
        display: flex;
        flex-wrap: wrap;
        gap: 25px;
        align-items: center;
        justify-content: center;
      }

      .problem-item {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .problem-label {
        font-family: "Caveat", cursive;
        font-size: 1.4rem;
        color: #6c584c;
        font-weight: 600;
      }

      .mini-nodes {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .mini-node {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: "Caveat", cursive;
        font-size: 1.3rem;
        font-weight: 700;
        color: white;
        box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
      }

      .mini-node.l1 {
        background: linear-gradient(135deg, #4361ee, #3a0ca3);
      }
      .mini-node.l2 {
        background: linear-gradient(135deg, #f72585, #b5179e);
      }

      .mini-arrow {
        color: #adb5bd;
        font-size: 1rem;
      }

      /* Main Visualization Container */
      .viz-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 25px;
        margin-bottom: 25px;
      }

      @media (max-width: 1000px) {
        .viz-container {
          grid-template-columns: 1fr;
        }
      }

      /* Call Stack Section */
      .stack-section {
        background: linear-gradient(180deg, #2b2d42, #1a1a2e);
        border-radius: 15px;
        padding: 20px;
        box-shadow: 5px 5px 0 rgba(0, 0, 0, 0.2);
      }

      .stack-title {
        font-family: "Permanent Marker", cursive;
        font-size: 1.4rem;
        color: #4cc9f0;
        margin-bottom: 15px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .stack-container {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .stack-frame {
        background: linear-gradient(135deg, #3a0ca3, #4361ee);
        border-radius: 10px;
        padding: 12px 15px;
        border-left: 5px solid #4cc9f0;
        transition: all 0.4s ease;
        opacity: 0.4;
        transform: translateX(-20px);
      }

      .stack-frame.active {
        opacity: 1;
        transform: translateX(0);
        box-shadow: 0 0 20px rgba(76, 201, 240, 0.4);
      }

      .stack-frame.returning {
        background: linear-gradient(135deg, #2d6a4f, #40916c);
        border-left-color: #95d5b2;
      }

      .stack-frame.completed {
        opacity: 0.6;
        background: linear-gradient(135deg, #6c757d, #495057);
      }

      .frame-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .frame-number {
        font-family: "Permanent Marker", cursive;
        font-size: 0.9rem;
        color: #4cc9f0;
        background: rgba(0, 0, 0, 0.3);
        padding: 2px 10px;
        border-radius: 10px;
      }

      .frame-status {
        font-family: "Caveat", cursive;
        font-size: 1rem;
        padding: 2px 10px;
        border-radius: 10px;
      }

      .frame-status.calling {
        background: #f72585;
        color: white;
      }

      .frame-status.returning {
        background: #52b788;
        color: white;
      }

      .frame-content {
        font-family: "Courier New", monospace;
        font-size: 0.85rem;
        color: #e0e0e0;
        line-height: 1.5;
      }

      .frame-args {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
      }

      .arg-item {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .arg-label {
        color: #4cc9f0;
      }

      .arg-nodes {
        display: flex;
        align-items: center;
        gap: 3px;
      }

      .tiny-node {
        width: 24px;
        height: 24px;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: "Caveat", cursive;
        font-size: 0.95rem;
        font-weight: 700;
        color: white;
      }

      .tiny-node.l1 {
        background: #4361ee;
      }
      .tiny-node.l2 {
        background: #f72585;
      }

      .tiny-arrow {
        color: #6c757d;
        font-size: 0.8rem;
      }

      .arg-null {
        color: #adb5bd;
        font-style: italic;
        font-family: "Indie Flower", cursive;
      }

      .frame-return {
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px dashed rgba(255, 255, 255, 0.2);
        color: #95d5b2;
      }

      .return-label {
        font-family: "Caveat", cursive;
        color: #52b788;
      }

      /* Unwinding Section */
      .unwind-section {
        background: linear-gradient(180deg, #fff8e7, #ffecd2);
        border-radius: 15px;
        padding: 20px;
        border: 3px solid #dda15e;
        box-shadow: 5px 5px 0 rgba(221, 161, 94, 0.3);
      }

      .unwind-title {
        font-family: "Permanent Marker", cursive;
        font-size: 1.4rem;
        color: #bc6c25;
        margin-bottom: 15px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .step-card {
        background: white;
        border-radius: 12px;
        padding: 15px;
        margin-bottom: 12px;
        border-left: 5px solid;
        box-shadow: 3px 3px 0 rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
        opacity: 0.3;
        transform: scale(0.95);
      }

      .step-card.active {
        opacity: 1;
        transform: scale(1);
      }

      .step-card.phase-down {
        border-color: #4361ee;
      }
      .step-card.phase-base {
        border-color: #f72585;
      }
      .step-card.phase-up {
        border-color: #52b788;
      }

      .step-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        flex-wrap: wrap;
        gap: 8px;
      }

      .step-badge {
        font-family: "Permanent Marker", cursive;
        font-size: 1rem;
        padding: 3px 12px;
        border-radius: 15px;
        color: white;
      }

      .step-badge.down {
        background: #4361ee;
      }
      .step-badge.base {
        background: #f72585;
      }
      .step-badge.up {
        background: #52b788;
      }

      .step-comparison {
        font-family: "Architects Daughter", cursive;
        font-size: 1.1rem;
        color: #6c584c;
      }

      .compare-values {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        background: rgba(0, 0, 0, 0.05);
        padding: 5px 12px;
        border-radius: 20px;
      }

      .val-l1 {
        color: #4361ee;
        font-weight: 700;
      }
      .val-l2 {
        color: #f72585;
        font-weight: 700;
      }
      .val-op {
        color: #bc6c25;
      }

      .step-action {
        font-family: "Caveat", cursive;
        font-size: 1.2rem;
        color: #1b4332;
        margin-top: 8px;
        padding: 8px 12px;
        background: linear-gradient(
          90deg,
          rgba(82, 183, 136, 0.1),
          transparent
        );
        border-radius: 8px;
      }

      .action-highlight {
        color: #e76f51;
        font-weight: 700;
      }

      /* Tree Visualization */
      .tree-section {
        background: linear-gradient(135deg, #1a1a2e, #2b2d42);
        border-radius: 15px;
        padding: 25px;
        margin-bottom: 25px;
        box-shadow: 5px 5px 0 rgba(0, 0, 0, 0.3);
      }

      .tree-title {
        font-family: "Permanent Marker", cursive;
        font-size: 1.5rem;
        color: #4cc9f0;
        margin-bottom: 20px;
        text-align: center;
      }

      .tree-container {
        overflow-x: auto;
        padding: 10px;
      }

      .tree-svg {
        display: block;
        margin: 0 auto;
      }

      /* Final Result */
      .final-result {
        background: linear-gradient(135deg, #d8f3dc, #95d5b2);
        border: 4px solid #40916c;
        border-radius: 20px;
        padding: 30px;
        text-align: center;
        box-shadow: 8px 8px 0 rgba(64, 145, 108, 0.3);
      }

      .final-title {
        font-family: "Permanent Marker", cursive;
        font-size: 1.8rem;
        color: #1b4332;
        margin-bottom: 20px;
      }

      .final-nodes {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
        margin-bottom: 25px;
      }

      .final-node {
        width: 55px;
        height: 55px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: "Caveat", cursive;
        font-size: 1.8rem;
        font-weight: 700;
        color: white;
        box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.3);
        animation: popIn 0.5s ease backwards;
      }

      .final-node:nth-child(1) {
        animation-delay: 0.6s;
      }
      .final-node:nth-child(3) {
        animation-delay: 0.5s;
      }
      .final-node:nth-child(5) {
        animation-delay: 0.4s;
      }
      .final-node:nth-child(7) {
        animation-delay: 0.3s;
      }
      .final-node:nth-child(9) {
        animation-delay: 0.2s;
      }
      .final-node:nth-child(11) {
        animation-delay: 0.1s;
      }

      .final-node.from-l1 {
        background: linear-gradient(135deg, #4361ee, #3a0ca3);
      }
      .final-node.from-l2 {
        background: linear-gradient(135deg, #f72585, #b5179e);
      }

      .final-arrow {
        font-size: 1.6rem;
        color: #2d6a4f;
      }

      @keyframes popIn {
        0% {
          opacity: 0;
          transform: scale(0) rotate(-180deg);
        }
        70% {
          transform: scale(1.2) rotate(10deg);
        }
        100% {
          opacity: 1;
          transform: scale(1) rotate(0deg);
        }
      }

      /* Code Section */
      .code-section {
        background: #1e1e1e;
        border-radius: 12px;
        padding: 20px;
        margin-top: 20px;
        overflow-x: auto;
      }

      .code-title {
        font-family: "Permanent Marker", cursive;
        font-size: 1.1rem;
        color: #4cc9f0;
        margin-bottom: 12px;
      }

      .code-block {
        font-family: "Courier New", monospace;
        font-size: 0.9rem;
        line-height: 1.7;
        color: #d4d4d4;
      }

      .code-keyword {
        color: #c586c0;
      }
      .code-function {
        color: #dcdcaa;
      }
      .code-param {
        color: #9cdcfe;
      }
      .code-comment {
        color: #6a9955;
      }
      .code-return {
        color: #569cd6;
      }
      .code-null {
        color: #569cd6;
      }
      .code-highlight-line {
        background: rgba(255, 235, 59, 0.15);
        display: block;
        margin: 0 -20px;
        padding: 0 20px;
      }

      /* Complexity Section */
      .complexity-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-top: 20px;
      }

      .complexity-card {
        background: white;
        border-radius: 15px;
        padding: 20px;
        text-align: center;
        box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.1);
        border: 3px solid;
      }

      .complexity-card.time {
        border-color: #4361ee;
      }
      .complexity-card.space {
        border-color: #f72585;
      }
      .complexity-card.note {
        border-color: #dda15e;
      }

      .complexity-icon {
        font-size: 2.2rem;
        margin-bottom: 8px;
      }

      .complexity-label {
        font-family: "Architects Daughter", cursive;
        font-size: 1.1rem;
        color: #6c584c;
        margin-bottom: 5px;
      }

      .complexity-value {
        font-family: "Permanent Marker", cursive;
        font-size: 1.6rem;
      }

      .complexity-card.time .complexity-value {
        color: #4361ee;
      }
      .complexity-card.space .complexity-value {
        color: #f72585;
      }
      .complexity-card.note .complexity-value {
        color: #bc6c25;
        font-size: 1.1rem;
      }

      /* Controls */
      .controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-top: 25px;
        flex-wrap: wrap;
      }

      .control-btn {
        font-family: "Caveat", cursive;
        font-size: 1.4rem;
        padding: 12px 28px;
        border: none;
        border-radius: 30px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.2);
      }

      .control-btn:active {
        transform: translate(2px, 2px);
        box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.2);
      }

      .control-btn.prev {
        background: linear-gradient(135deg, #6c757d, #495057);
        color: white;
      }

      .control-btn.next {
        background: linear-gradient(135deg, #4361ee, #3a0ca3);
        color: white;
      }

      .control-btn.reset {
        background: linear-gradient(135deg, #f72585, #b5179e);
        color: white;
      }

      .control-btn.auto {
        background: linear-gradient(135deg, #52b788, #40916c);
        color: white;
      }

      .control-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .step-indicator {
        font-family: "Permanent Marker", cursive;
        font-size: 1.2rem;
        color: #6c584c;
        text-align: center;
        margin-top: 15px;
      }

      /* Responsive */
      @media (max-width: 768px) {
        .whiteboard {
          padding: 20px 15px;
        }

        .whiteboard::after {
          left: 40px;
        }

        .title {
          font-size: 1.8rem;
        }

        .final-node {
          width: 45px;
          height: 45px;
          font-size: 1.4rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="whiteboard">
      <h1 class="title">üîÑ Recursive Merge Approach</h1>
      <p class="subtitle">Elegant Solution Using the Call Stack</p>

      <!-- Recursive Concept -->
      <div class="concept-box">
        <p class="concept-text">
          <strong>The Beautiful Recursive Idea:</strong> To merge two sorted
          lists, simply take the <em>smaller head</em>, and set its
          <code>.next</code> to be the result of recursively merging the rest!
        </p>
        <div class="concept-formula">
          <span class="formula-highlight">merge(L1, L2)</span> =
          <strong>smaller_head</strong> ‚Üí
          <span class="formula-highlight">merge(remaining)</span> <br /><br />
          <strong>Base Case:</strong> If either list is <code>null</code>,
          return the other list.
        </div>
      </div>

      <!-- Problem Statement -->
      <div class="problem-box">
        <div class="problem-item">
          <span class="problem-label">list1:</span>
          <div class="mini-nodes">
            <div class="mini-node l1">1</div>
            <span class="mini-arrow">‚Üí</span>
            <div class="mini-node l1">2</div>
            <span class="mini-arrow">‚Üí</span>
            <div class="mini-node l1">4</div>
          </div>
        </div>
        <div class="problem-item">
          <span class="problem-label">list2:</span>
          <div class="mini-nodes">
            <div class="mini-node l2">1</div>
            <span class="mini-arrow">‚Üí</span>
            <div class="mini-node l2">3</div>
            <span class="mini-arrow">‚Üí</span>
            <div class="mini-node l2">4</div>
          </div>
        </div>
      </div>

      <!-- Main Visualization -->
      <div class="viz-container">
        <!-- Call Stack -->
        <div class="stack-section">
          <div class="stack-title">
            <span>üìö</span>
            <span>Call Stack (grows downward)</span>
          </div>
          <div class="stack-container" id="stackContainer">
            <!-- Stack frames will be populated by JS -->
          </div>
        </div>

        <!-- Step by Step -->
        <div class="unwind-section">
          <div class="unwind-title">
            <span>üìù</span>
            <span>Step-by-Step Execution</span>
          </div>
          <div id="stepsContainer">
            <!-- Steps will be populated by JS -->
          </div>
        </div>
      </div>

      <!-- Recursion Tree Visualization -->
      <div class="tree-section">
        <div class="tree-title">üå≥ Recursion Tree - Watch It Unfold!</div>
        <div class="tree-container">
          <svg
            class="tree-svg"
            width="900"
            height="380"
            viewBox="0 0 900 380"
            id="treeSvg"
          >
            <!-- Tree nodes and edges drawn by JS -->
          </svg>
        </div>
      </div>

      <!-- Final Result -->
      <div class="final-result" id="finalResult" style="display: none">
        <div class="final-title">‚úÖ Recursion Unwound ‚Äî Final Merged List!</div>
        <div class="final-nodes">
          <div class="final-node from-l1">1</div>
          <span class="final-arrow">‚Üí</span>
          <div class="final-node from-l2">1</div>
          <span class="final-arrow">‚Üí</span>
          <div class="final-node from-l1">2</div>
          <span class="final-arrow">‚Üí</span>
          <div class="final-node from-l2">3</div>
          <span class="final-arrow">‚Üí</span>
          <div class="final-node from-l1">4</div>
          <span class="final-arrow">‚Üí</span>
          <div class="final-node from-l2">4</div>
        </div>

        <!-- Code -->
        <div class="code-section">
          <div class="code-title">üíª Recursive Implementation</div>
          <pre
            class="code-block"
          ><span class="code-keyword">function</span> <span class="code-function">mergeTwoLists</span>(<span class="code-param">list1</span>, <span class="code-param">list2</span>) {
    <span class="code-comment">// Base cases</span>
    <span class="code-keyword">if</span> (<span class="code-param">list1</span> === <span class="code-null">null</span>) <span class="code-return">return</span> <span class="code-param">list2</span>;
    <span class="code-keyword">if</span> (<span class="code-param">list2</span> === <span class="code-null">null</span>) <span class="code-return">return</span> <span class="code-param">list1</span>;
    
    <span class="code-comment">// Recursive case</span>
    <span class="code-keyword">if</span> (<span class="code-param">list1</span>.val <= <span class="code-param">list2</span>.val) {
<span class="code-highlight-line">        <span class="code-param">list1</span>.next = <span class="code-function">mergeTwoLists</span>(<span class="code-param">list1</span>.next, <span class="code-param">list2</span>);</span>
        <span class="code-return">return</span> <span class="code-param">list1</span>;
    } <span class="code-keyword">else</span> {
        <span class="code-param">list2</span>.next = <span class="code-function">mergeTwoLists</span>(<span class="code-param">list1</span>, <span class="code-param">list2</span>.next);
        <span class="code-return">return</span> <span class="code-param">list2</span>;
    }
}</pre>
        </div>

        <!-- Complexity -->
        <div class="complexity-grid">
          <div class="complexity-card time">
            <div class="complexity-icon">‚è±Ô∏è</div>
            <div class="complexity-label">Time Complexity</div>
            <div class="complexity-value">O(n + m)</div>
          </div>
          <div class="complexity-card space">
            <div class="complexity-icon">üìö</div>
            <div class="complexity-label">Space Complexity</div>
            <div class="complexity-value">O(n + m)</div>
          </div>
          <div class="complexity-card note">
            <div class="complexity-icon">‚ö†Ô∏è</div>
            <div class="complexity-label">Stack Space</div>
            <div class="complexity-value">Call stack depth = n + m</div>
          </div>
        </div>
      </div>

      <!-- Controls -->
      <div class="controls">
        <button class="control-btn prev" onclick="prevStep()" id="prevBtn">
          ‚Üê Previous
        </button>
        <button class="control-btn next" onclick="nextStep()" id="nextBtn">
          Next ‚Üí
        </button>
        <button class="control-btn auto" onclick="autoPlay()" id="autoBtn">
          ‚ñ∂ Auto Play
        </button>
        <button class="control-btn reset" onclick="resetAll()">üîÑ Reset</button>
      </div>
      <div class="step-indicator" id="stepIndicator">Step 0 of 12</div>
    </div>

    <script>
      // Execution steps data
      const steps = [
        {
          phase: "down",
          call: 1,
          l1: [1, 2, 4],
          l2: [1, 3, 4],
          compare: "1 ‚â§ 1",
          result: "YES",
          action: "list1.next = merge([2,4], [1,3,4])",
          pick: "l1",
          pickVal: 1,
        },
        {
          phase: "down",
          call: 2,
          l1: [2, 4],
          l2: [1, 3, 4],
          compare: "2 ‚â§ 1",
          result: "NO",
          action: "list2.next = merge([2,4], [3,4])",
          pick: "l2",
          pickVal: 1,
        },
        {
          phase: "down",
          call: 3,
          l1: [2, 4],
          l2: [3, 4],
          compare: "2 ‚â§ 3",
          result: "YES",
          action: "list1.next = merge([4], [3,4])",
          pick: "l1",
          pickVal: 2,
        },
        {
          phase: "down",
          call: 4,
          l1: [4],
          l2: [3, 4],
          compare: "4 ‚â§ 3",
          result: "NO",
          action: "list2.next = merge([4], [4])",
          pick: "l2",
          pickVal: 3,
        },
        {
          phase: "down",
          call: 5,
          l1: [4],
          l2: [4],
          compare: "4 ‚â§ 4",
          result: "YES",
          action: "list1.next = merge([], [4])",
          pick: "l1",
          pickVal: 4,
        },
        {
          phase: "base",
          call: 6,
          l1: [],
          l2: [4],
          compare: null,
          result: null,
          action: "list1 is null ‚Üí return list2 = [4]",
          pick: "l2",
          pickVal: 4,
          returnVal: "[4]",
        },
        {
          phase: "up",
          call: 5,
          action: "list1.next = [4] ‚Üí return [4‚Üí4]",
          returnVal: "[4‚Üí4]",
        },
        {
          phase: "up",
          call: 4,
          action: "list2.next = [4‚Üí4] ‚Üí return [3‚Üí4‚Üí4]",
          returnVal: "[3‚Üí4‚Üí4]",
        },
        {
          phase: "up",
          call: 3,
          action: "list1.next = [3‚Üí4‚Üí4] ‚Üí return [2‚Üí3‚Üí4‚Üí4]",
          returnVal: "[2‚Üí3‚Üí4‚Üí4]",
        },
        {
          phase: "up",
          call: 2,
          action: "list2.next = [2‚Üí3‚Üí4‚Üí4] ‚Üí return [1‚Üí2‚Üí3‚Üí4‚Üí4]",
          returnVal: "[1‚Üí2‚Üí3‚Üí4‚Üí4]",
        },
        {
          phase: "up",
          call: 1,
          action: "list1.next = [1‚Üí2‚Üí3‚Üí4‚Üí4] ‚Üí return [1‚Üí1‚Üí2‚Üí3‚Üí4‚Üí4]",
          returnVal: "[1‚Üí1‚Üí2‚Üí3‚Üí4‚Üí4]",
        },
        {
          phase: "done",
          action: "Final result: [1‚Üí1‚Üí2‚Üí3‚Üí4‚Üí4]",
        },
      ];

      let currentStep = 0;
      let autoPlayInterval = null;

      // Tree node positions
      const treeNodes = [
        { id: 1, x: 450, y: 30, l1: "[1,2,4]", l2: "[1,3,4]" },
        { id: 2, x: 300, y: 90, l1: "[2,4]", l2: "[1,3,4]" },
        { id: 3, x: 200, y: 150, l1: "[2,4]", l2: "[3,4]" },
        { id: 4, x: 350, y: 210, l1: "[4]", l2: "[3,4]" },
        { id: 5, x: 500, y: 270, l1: "[4]", l2: "[4]" },
        { id: 6, x: 650, y: 330, l1: "[]", l2: "[4]" },
      ];

      const treeEdges = [
        { from: 1, to: 2 },
        { from: 2, to: 3 },
        { from: 3, to: 4 },
        { from: 4, to: 5 },
        { from: 5, to: 6 },
      ];

      function renderStackFrames() {
        const container = document.getElementById("stackContainer");
        container.innerHTML = "";

        const activeFrames = [];
        for (let i = 0; i <= currentStep && i < steps.length; i++) {
          const step = steps[i];
          if (step.phase === "down" || step.phase === "base") {
            activeFrames.push({ ...step, stepIndex: i });
          } else if (step.phase === "up") {
            // Mark top frame as returning
            if (activeFrames.length > 0) {
              const topFrame = activeFrames[activeFrames.length - 1];
              if (topFrame.call === step.call) {
                topFrame.returning = true;
                topFrame.returnVal = step.returnVal;
              }
            }
          }
        }

        // Remove completed frames for 'up' phase
        const displayFrames = [];
        let returningCount = 0;
        for (let i = 0; i <= currentStep && i < steps.length; i++) {
          if (steps[i].phase === "up") returningCount++;
        }

        const framesToShow = activeFrames.slice(
          0,
          activeFrames.length - Math.max(0, returningCount - 1)
        );

        framesToShow.forEach((frame, idx) => {
          const isActive = idx === framesToShow.length - 1;
          const isReturning = frame.returning && isActive;

          const frameEl = document.createElement("div");
          frameEl.className = `stack-frame ${isActive ? "active" : ""} ${
            isReturning ? "returning" : ""
          }`;

          let l1Display =
            frame.l1 && frame.l1.length > 0
              ? frame.l1
                  .map((v) => `<span class="tiny-node l1">${v}</span>`)
                  .join('<span class="tiny-arrow">‚Üí</span>')
              : '<span class="arg-null">null</span>';

          let l2Display =
            frame.l2 && frame.l2.length > 0
              ? frame.l2
                  .map((v) => `<span class="tiny-node l2">${v}</span>`)
                  .join('<span class="tiny-arrow">‚Üí</span>')
              : '<span class="arg-null">null</span>';

          frameEl.innerHTML = `
                    <div class="frame-header">
                        <span class="frame-number">Call #${frame.call}</span>
                        ${
                          isReturning
                            ? '<span class="frame-status returning">‚Ü© Returning</span>'
                            : isActive
                            ? '<span class="frame-status calling">‚ñ∂ Active</span>'
                            : ""
                        }
                    </div>
                    <div class="frame-content">
                        <div class="frame-args">
                            <div class="arg-item">
                                <span class="arg-label">L1:</span>
                                <div class="arg-nodes">${l1Display}</div>
                            </div>
                            <div class="arg-item">
                                <span class="arg-label">L2:</span>
                                <div class="arg-nodes">${l2Display}</div>
                            </div>
                        </div>
                        ${
                          isReturning
                            ? `<div class="frame-return"><span class="return-label">Returns:</span> ${frame.returnVal}</div>`
                            : ""
                        }
                    </div>
                `;

          container.appendChild(frameEl);
        });
      }

      function renderSteps() {
        const container = document.getElementById("stepsContainer");
        container.innerHTML = "";

        const stepsToShow = Math.min(currentStep + 1, steps.length);

        for (let i = 0; i < stepsToShow; i++) {
          const step = steps[i];
          const isActive = i === currentStep;

          const stepEl = document.createElement("div");
          stepEl.className = `step-card phase-${step.phase} ${
            isActive ? "active" : ""
          }`;

          let content = "";

          if (step.phase === "down") {
            content = `
                        <div class="step-header">
                            <span class="step-badge down">Call #${
                              step.call
                            } ‚¨á</span>
                            <div class="step-comparison">
                                <span class="compare-values">
                                    <span class="val-l1">${step.l1[0]}</span>
                                    <span class="val-op">‚â§</span>
                                    <span class="val-l2">${step.l2[0]}</span>
                                    <span class="val-op">?</span>
                                    <span>${step.result}</span>
                                </span>
                            </div>
                        </div>
                        <div class="step-action">
                            Pick <span class="action-highlight">${
                              step.pick === "l1" ? "list1" : "list2"
                            }'s ${step.pickVal}</span>, 
                            recurse on rest
                        </div>
                    `;
          } else if (step.phase === "base") {
            content = `
                        <div class="step-header">
                            <span class="step-badge base">Call #${step.call} üéØ</span>
                            <span style="color: #f72585; font-family: 'Caveat', cursive; font-size: 1.1rem;">BASE CASE!</span>
                        </div>
                        <div class="step-action">
                            list1 is <span class="action-highlight">null</span> ‚Üí return list2 = <span class="action-highlight">[4]</span>
                        </div>
                    `;
          } else if (step.phase === "up") {
            content = `
                        <div class="step-header">
                            <span class="step-badge up">Return #${step.call} ‚¨Ü</span>
                        </div>
                        <div class="step-action">
                            ${step.action} ‚Üí <span class="action-highlight">${step.returnVal}</span>
                        </div>
                    `;
          } else if (step.phase === "done") {
            content = `
                        <div class="step-header">
                            <span class="step-badge up">‚úÖ DONE</span>
                        </div>
                        <div class="step-action">
                            <span class="action-highlight">${step.action}</span>
                        </div>
                    `;
          }

          stepEl.innerHTML = content;
          container.appendChild(stepEl);
        }

        // Scroll to bottom
        container.scrollTop = container.scrollHeight;
      }

      function renderTree() {
        const svg = document.getElementById("treeSvg");
        svg.innerHTML = "";

        // Draw edges
        treeEdges.forEach((edge, idx) => {
          const from = treeNodes.find((n) => n.id === edge.from);
          const to = treeNodes.find((n) => n.id === edge.to);

          // Determine if edge should be visible
          const edgeStep = idx; // edge 0 shows at step 1, etc.
          const isVisible = currentStep >= edgeStep;
          const isReturning = currentStep >= 6 + (5 - idx);

          if (isVisible) {
            const line = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "line"
            );
            line.setAttribute("x1", from.x);
            line.setAttribute("y1", from.y + 20);
            line.setAttribute("x2", to.x);
            line.setAttribute("y2", to.y - 20);
            line.setAttribute("stroke", isReturning ? "#52b788" : "#4361ee");
            line.setAttribute("stroke-width", "3");
            line.setAttribute("stroke-dasharray", isReturning ? "none" : "8,4");
            line.setAttribute("opacity", isReturning ? "1" : "0.6");
            svg.appendChild(line);

            // Arrow head
            if (!isReturning) {
              const angle = Math.atan2(to.y - from.y, to.x - from.x);
              const arrowSize = 10;
              const arrowX = to.x - 25 * Math.cos(angle);
              const arrowY = to.y - 25 * Math.sin(angle);

              const arrow = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "polygon"
              );
              const p1 = `${arrowX},${arrowY}`;
              const p2 = `${arrowX - arrowSize * Math.cos(angle - 0.5)},${
                arrowY - arrowSize * Math.sin(angle - 0.5)
              }`;
              const p3 = `${arrowX - arrowSize * Math.cos(angle + 0.5)},${
                arrowY - arrowSize * Math.sin(angle + 0.5)
              }`;
              arrow.setAttribute("points", `${p1} ${p2} ${p3}`);
              arrow.setAttribute("fill", "#4361ee");
              arrow.setAttribute("opacity", "0.6");
              svg.appendChild(arrow);
            }
          }
        });

        // Draw nodes
        treeNodes.forEach((node, idx) => {
          const nodeStep = idx;
          const isVisible = currentStep >= nodeStep;
          const isActive =
            currentStep === nodeStep ||
            (currentStep >= 6 && currentStep === 11 - idx);
          const isReturning = currentStep >= 6 + (5 - idx);
          const isBaseCase = idx === 5;

          if (isVisible) {
            // Node background
            const rect = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "rect"
            );
            rect.setAttribute("x", node.x - 70);
            rect.setAttribute("y", node.y - 18);
            rect.setAttribute("width", "140");
            rect.setAttribute("height", "36");
            rect.setAttribute("rx", "8");

            let fill = "#3a0ca3";
            if (isBaseCase && currentStep >= 5) fill = "#b5179e";
            if (isReturning) fill = "#2d6a4f";

            rect.setAttribute("fill", fill);
            rect.setAttribute("opacity", isActive ? "1" : "0.7");

            if (isActive) {
              rect.setAttribute("stroke", "#4cc9f0");
              rect.setAttribute("stroke-width", "3");
            }

            svg.appendChild(rect);

            // Node text
            const text = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "text"
            );
            text.setAttribute("x", node.x);
            text.setAttribute("y", node.y + 5);
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("fill", "white");
            text.setAttribute("font-family", "Caveat, cursive");
            text.setAttribute("font-size", "14");
            text.textContent = `${node.l1}, ${node.l2}`;
            svg.appendChild(text);

            // Return value annotation
            if (isReturning && currentStep >= 6) {
              const returnVals = [
                "[4]",
                "[4‚Üí4]",
                "[3‚Üí4‚Üí4]",
                "[2‚Üí3‚Üí4‚Üí4]",
                "[1‚Üí2‚Üí3‚Üí4‚Üí4]",
                "[1‚Üí1‚Üí2‚Üí3‚Üí4‚Üí4]",
              ];
              const retIdx = 5 - idx;
              if (
                currentStep >= 6 + retIdx &&
                retIdx >= 0 &&
                retIdx < returnVals.length
              ) {
                const retText = document.createElementNS(
                  "http://www.w3.org/2000/svg",
                  "text"
                );
                retText.setAttribute("x", node.x + 80);
                retText.setAttribute("y", node.y + 5);
                retText.setAttribute("fill", "#95d5b2");
                retText.setAttribute("font-family", "Courier New, monospace");
                retText.setAttribute("font-size", "11");
                retText.textContent = `‚Üí ${returnVals[retIdx]}`;
                svg.appendChild(retText);
              }
            }
          }
        });
      }

      function updateDisplay() {
        renderStackFrames();
        renderSteps();
        renderTree();

        // Update indicator
        document.getElementById(
          "stepIndicator"
        ).textContent = `Step ${currentStep} of ${steps.length - 1}`;

        // Update buttons
        document.getElementById("prevBtn").disabled = currentStep === 0;
        document.getElementById("nextBtn").disabled =
          currentStep === steps.length - 1;

        // Show final result
        const finalResult = document.getElementById("finalResult");
        if (currentStep === steps.length - 1) {
          finalResult.style.display = "block";
          // Trigger animation
          const nodes = finalResult.querySelectorAll(".final-node");
          nodes.forEach((node, idx) => {
            node.style.animation = "none";
            node.offsetHeight;
            node.style.animation = `popIn 0.5s ease backwards ${
              0.6 - idx * 0.1
            }s`;
          });
        } else {
          finalResult.style.display = "none";
        }
      }

      function nextStep() {
        if (currentStep < steps.length - 1) {
          currentStep++;
          updateDisplay();
        }
      }

      function prevStep() {
        if (currentStep > 0) {
          currentStep--;
          updateDisplay();
        }
      }

      function resetAll() {
        stopAutoPlay();
        currentStep = 0;
        updateDisplay();
      }

      function autoPlay() {
        if (autoPlayInterval) {
          stopAutoPlay();
          return;
        }

        document.getElementById("autoBtn").textContent = "‚è∏ Pause";
        autoPlayInterval = setInterval(() => {
          if (currentStep < steps.length - 1) {
            nextStep();
          } else {
            stopAutoPlay();
          }
        }, 1500);
      }

      function stopAutoPlay() {
        if (autoPlayInterval) {
          clearInterval(autoPlayInterval);
          autoPlayInterval = null;
        }
        document.getElementById("autoBtn").textContent = "‚ñ∂ Auto Play";
      }

      // Keyboard navigation
      document.addEventListener("keydown", (e) => {
        if (e.key === "ArrowRight" || e.key === " ") {
          e.preventDefault();
          nextStep();
        } else if (e.key === "ArrowLeft") {
          prevStep();
        } else if (e.key === "r" || e.key === "R") {
          resetAll();
        } else if (e.key === "p" || e.key === "P") {
          autoPlay();
        }
      });

      // Initialize
      updateDisplay();
    </script>
  </body>
</html>
